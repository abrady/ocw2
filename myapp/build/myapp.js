var __DEV__ = true;
var __PERF__ = false;
// modulr.sync.js (c) 2010 Tobie Langel
(function(exports) {
  var modulr = {},
      _factories = {},
      _modules = {},
      PREFIX = '__module__', // Poor man's hasOwnProperty
      RELATIVE_IDENTIFIER_PATTERN = /^\.\.?\//;

  if (__PERF__) {
    var _perf = modulr.perf = {
      start: Date.now(),
      modules: {}
    },
    _pos = 1;
  }

  function makeRequire(id, main) {
    // Find the requirer's dirname from it's id.
    var path = id.substring(0, id.lastIndexOf('/') + 1);

    function require(identifier) {
      if (__PERF__) { var t0 = Date.now(); }
      var id = resolveIdentifier(identifier, path),
          key = PREFIX + id,
          mod = _modules[key];

      if (__PERF__) {
        var _p = _perf.modules[id];
        _p.count++;
      }
      // Check if this module's factory has already been called.
      if (!mod) {
        if (__PERF__) {
          _p.left = _pos++;
          _p.start = t0;
        }
        var fn = _factories[key];
        delete _factories[key]; // no longer needed.

        if (!fn) { throw 'Can\'t find module "' + identifier + '".'; }

        // lazy eval
        if (typeof fn === 'string') {
          if (__PERF__) { _p.evalStart = Date.now(); }
          fn = new Function('require', 'exports', 'module', fn);
          if (__PERF__) { _p.evalEnd = Date.now(); }
        }

        _modules[key] = mod = { id: id, exports: {} };
        // Create an instance of `require` per module. Each instance has a
        // reference to the path it was called from to be able to properly
        // resolve relative identifiers.
        // `main` isn't defined until we actually require the program's
        // entry point.
        var r = makeRequire(id, main || mod);
        fn.call(exports, r, mod.exports, mod);
        if (__PERF__) {
          _p.right = _pos++;
          _p.end = Date.now();
        }
      }
      return mod.exports;
    }

    require.main = main;
    return require;
  }

  function resolveIdentifier(identifier, dir) {
    var parts, part, path;
    
    if (!RELATIVE_IDENTIFIER_PATTERN.test(identifier)) {
      return identifier;
    }

    parts = (dir + identifier).split('/');

    path = [];
    for (var i = 0, length = parts.length; i < length; i++) {
      part = parts[i];
      switch (part) {
        case '':
        case '.':
          continue;
        case '..':
          if (path.length) {
            path.pop();
          } else {
            throw new RangeError('Out of bounds identifier: ' + identifier);
          }
          break;
        default:
          path.push(part);
      }
    }
    return path.join('/');
  }
  
  function define(id, factory) {
    if (__PERF__) { _perf.modules[id] = { count: 0 }; }
    _factories[PREFIX + id] = factory;
  }
  
  exports.define = define;
  exports.require = makeRequire('');
  exports.modulr = modulr;
})(this);

if (__PERF__) { modulr.perf.defineStart = Date.now(); }


// module: bolt/dom
// file:   ../bolt/bolt/lib/dom/index.js
define("bolt/dom", function(require, exports, module) {
module.exports = require("bolt/dom/index");});

// module: lib/sample-view
// file:   lib/sample-view/index.js
define("lib/sample-view", function(require, exports, module) {
module.exports = require("lib/sample-view/index");});

// module: bolt_touch/views/button
// file:   ../bolt/bolt_touch/lib/views/button/index.js
define("bolt_touch/views/button", function(require, exports, module) {
module.exports = require("bolt_touch/views/button/index");});

// module: bolt/util/assert
// file:   ../bolt/bolt/lib/util/assert.js
eval("define(\"bolt/util/assert\", function(require, exports, module) { /**\n *\n * Copyright (c) 2011-2012, Facebook, Inc.\n * All rights reserved.\n *\n * @preserve-header\n *\n */\n\n'use strict';\n\nfunction assert(test, message) {\n  if (!test) {\n    throw new Error(message);\n  }\n}\n\nexports.assert = assert;\n\n//@ sourceURL=bolt/util/assert\n});");

// module: lib/main
// file:   lib/main.js
eval("define(\"lib/main\", function(require, exports, module) { // this is the main file where your application startup begins\n\nrequire('./sample-view').init();\n\nvar SampleView = require('./sample-view').SampleView;\nvar ButtonExample = require('./sample-view').ButtonExample;\n\n(new SampleView({})).placeIn(document.body);\n\n//@ sourceURL=lib/main\n});");

// module: bolt/util/array
// file:   ../bolt/bolt/lib/util/array.js
eval("define(\"bolt/util/array\", function(require, exports, module) { /**\n *\n * Copyright (c) 2011-2012, Facebook, Inc.\n * All rights reserved.\n *\n * @preserve-header\n *\n */\n\n'use strict';\n\nfunction remove(array, from, to) {\n  var rest = array.slice((to || from) + 1 || array.length);\n  array.length = from < 0 ? array.length + from : from;\n  return array.push.apply(array, rest);\n}\n\nexports.remove = remove;\n\n//@ sourceURL=bolt/util/array\n});");

// module: bolt/util/guid
// file:   ../bolt/bolt/lib/util/guid.js
eval("define(\"bolt/util/guid\", function(require, exports, module) { /**\n *\n * Copyright (c) 2011-2012, Facebook, Inc.\n * All rights reserved.\n *\n * @preserve-header\n *\n */\n\n'use strict';\n\nvar guidKey = '__bolt-' + (+ new Date());\nvar prependValue = 'bolt-';\nvar cid = 0;\n\nfunction generateGuid(object) {\n  cid += 1;\n  var value = prependValue + cid;\n  object[guidKey] = value;\n  return value;\n}\n\nfunction guidFor(object) {\n  if (object[guidKey]) {\n    return object[guidKey];\n  }\n\n  return generateGuid(object);\n}\n\nexports.guidFor = guidFor;\n\n//@ sourceURL=bolt/util/guid\n});");

// module: bolt_touch/view
// file:   ../bolt/bolt_touch/lib/view.js
eval("define(\"bolt_touch/view\", function(require, exports, module) { require('bolt/compat/view');\n\nvar core = require('bolt/core');\nvar BoltView = require('bolt/view').View;\n\n/**\n * The base view for Bolt Touch.\n */\nvar View = core.createClass({\n  // Don't override View in bolt/core.ClassRegistry.View as long as that is\n  // still around\n  name: 'TouchView',\n\n  extend: BoltView\n\n});\n\nexports.View = View;\n\n//is view running in a touchable device\nvar hasTouch = View.hasTouch = 'ontouchstart' in window;\n\n// map of touch events or mouse equivalents for testing in browser or device\nView.touchEvents = {\n  TOUCHSTART: hasTouch ? 'touchstart' : 'mousedown',\n  TOUCHEND: hasTouch ? 'touchend' : 'mouseup',\n  TOUCHMOVE: hasTouch ? 'touchmove' : 'mousemove',\n  TOUCHCANCEL: hasTouch ? 'touchend' : 'mouseup'\n};\n\n//@ sourceURL=bolt_touch/view\n});");

// module: bolt_touch/mixins/actionable
// file:   ../bolt/bolt_touch/lib/mixins/actionable.js
eval("define(\"bolt_touch/mixins/actionable\", function(require, exports, module) { var View = require('bolt_touch/view').View;\nvar util = require('bolt/util');\nvar dom = require('bolt/dom');\nvar Touchable = require('./touchable').Touchable;\n\nexports.Actionable = util.extend({}, Touchable, {\n\n  hasFinishedTouching: function(wasTouched, evt) {\n    if (wasTouched) {\n      evt.stopPropagation();\n      this.doAction(evt);\n    }\n  },\n\n  doAction: function(evt) {\n    var actions = this._actions;\n    var action;\n\n    if (!actions) {\n      return;\n    }\n\n    for (var i = 0; i < actions.length; i++) {\n      action = actions[i];\n      if (typeof action == 'string') {\n        var context = null;\n        var owner = this.getOwner();\n        if (owner[action]) {\n          context = owner;\n        } else {\n          context = this;\n        }\n        context[action](this, evt);\n      } else if (action) {\n        action(this, evt);\n      }\n    }\n  },\n\n  addAction: function(action) {\n    this._actions = this._actions || [];\n    this._actions.push(action);\n  },\n\n  setAction: function(action) {\n    this._actions = [action];\n  }\n\n});\n\n//@ sourceURL=bolt_touch/mixins/actionable\n});");

// module: bolt/mixins/responder
// file:   ../bolt/bolt/lib/mixins/responder.js
eval("define(\"bolt/mixins/responder\", function(require, exports, module) { /**\n *\n * Copyright (c) 2011-2012, Facebook, Inc.\n * All rights reserved.\n *\n * @preserve-header\n *\n */\n\n'use strict';\n\nvar defaultEventDispatcher = require('../event_dispatcher').getInstance();\n\nvar handlerNameCache = {};\nfunction eventHandlerNameFor(type) {\n  var value = handlerNameCache[type];\n  if (value) {\n    return value;\n  }\n  value = handlerNameCache[type] = 'on' + type.charAt(0).toUpperCase() + type.substr(1);\n  return value;\n}\n\nvar Responder = {\n\n  // ..........................................................\n  // Public\n  //\n\n  properties: {\n    // this is also defined in Container, and classes that mix both\n    // Container and Responder will 'overwrite' the property, but this\n    // is ok, since both point to the same default value\n    eventDispatcher: defaultEventDispatcher,\n    nextResponder: null\n  },\n\n  becomeFirstResponder: function() {\n    var eventDispatcher = this.getEventDispatcher();\n    eventDispatcher.becomeFirstResponder(this);\n  },\n\n  releaseFirstResponder: function() {\n    var eventDispatcher = this.getEventDispatcher();\n    eventDispatcher.releaseFirstResponder(this);\n  },\n\n  sendEvent: function(event) {\n    var onEventType;\n\n    if (this[event.type]) {\n      window.console && console.warn('There is a handler named after an event named. This syntax is no longer supported. Please use onEventname(). If this is a false alarm, ignore and we will remove this soon.');\n    }\n\n    onEventType = eventHandlerNameFor(event.type);\n    if (this[onEventType]) {\n      this[onEventType](event);\n      return true;\n    }\n\n    return false;\n  },\n\n  willLoseFirstResponder: null\n\n};\n\nexports.Responder = Responder;\n\n//@ sourceURL=bolt/mixins/responder\n});");

// module: bolt/mixins/custom_view_events
// file:   ../bolt/bolt/lib/mixins/custom_view_events.js
eval("define(\"bolt/mixins/custom_view_events\", function(require, exports, module) { var Container = require('./container').Container;\n\n/*\n  Adds support for a View owner listening to custom events on a view which it\n  creates.\n\n  Only views with a 'ref' can be listened to. The naming scheme is\n  identical to that used by the Events mixin for DOM events.\n\n  For example, if a view has the ref 'foo' and fires the\n  custom event 'bar', the function 'onFooBar' on the owner is automatically\n  set up as a listener for the 'bar' event on that View.\n*/\nexports.CustomViewEvents = {\n\n  __setup: Container.setup,\n\n  properties: {\n    events: null\n  },\n\n  setup: function(options) {\n    this.__setup(options);\n\n    var eventList = this.getEvents();\n    var ref = this.getRef();\n    var owner = this.getOwner();\n\n    // If the View has specified that it fires custom events, and it has a 'ref',\n    // check if the owner has functions that should be automatically hooked up\n    // as listeners.\n    if (eventList && eventList.length > 0 && ref && owner !== this) {\n      var refEventPrefix = 'on' + ref.charAt(0).toUpperCase() + ref.substring(1);\n\n      var fnName;\n      var eventName;\n\n      for (var i = 0, len = eventList.length; i < len; i++) {\n        eventName = eventList[i];\n        fnName = refEventPrefix + eventName.charAt(0).toUpperCase() + eventName.substring(1);\n\n        if (owner[fnName]) {\n          this.addListener(eventName, fnName, owner);\n        }\n\n        if (__DEV__) {\n          if (!owner[fnName]) {\n            console.error('The owner:', owner, 'of the view ',\n              this.getDeclaredClass(), 'does not have a method called '+fnName,\n              '. This method should be there, because you specified to listen',\n              'to the event', eventName, 'on the ref', ref);\n          }\n        }\n      }\n    }\n  }\n};\n\n//@ sourceURL=bolt/mixins/custom_view_events\n});");

// module: bolt_touch/views/button/index
// file:   ../bolt/bolt_touch/lib/views/button/index.js
eval("define(\"bolt_touch/views/button/index\", function(require, exports, module) { var util = require('bolt/util');\nvar View = require('bolt_touch/view').View;\nvar Actionable = require('../../mixins/actionable').Actionable;\n\nvar Button = require('bolt/core').createClass({\n\n  name: 'Button',\n\n  extend: View,\n\n  properties: {\n    value: ''\n  },\n\n  mixins: [Actionable],\n\n  declare: function(options) {\n    // TODO: wbailey we should come up with a general solution for this the\n    // problem is that passing in view properties lets you break the\n    // internals of a control in some cases. In this case passing in your own\n    // additionalClasses was overriding the additionalClasses that Button\n    // needs to render properly.\n    var defaultButtonClasses = 'uiButton uiButtonNoText';\n    if (options.additionalClasses) {\n      options.additionalClasses += ' ' + defaultButtonClasses;\n    }\n    return {\n      tagName: 'label',\n      additionalClasses: defaultButtonClasses,\n      childViews: [\n        {\n          ref: 'button',\n          tagName: 'input',\n          type: 'button',\n          className: 'uiButtonInput bt-button-input'\n        }\n      ]\n    };\n  },\n\n  setLarge: function(state) {\n    this.large = state;\n    this.toggleClass('uiButtonLarge', state);\n  },\n\n  getLarge: function(state) {\n    return this.large;\n  },\n\n  setValue: function(value) {\n    this.refs.button.getNode().value = value;\n  },\n\n  getValue: function() {\n    return this.refs.button.getNode().value;\n  },\n\n  setUse: function(use) {\n    this.toggleClass(useClassName(this.use), false);\n    this.use = use;\n    this.toggleClass(useClassName(this.use), true);\n    return this;\n  },\n\n  getUse: function() {\n    return this.use;\n  },\n\n  setDisabled: function(disabled) {\n    this.set('disabled', disabled);\n    this.toggleClass('uiButtonDisabled', disabled);\n  },\n\n  setDown: function(down) {\n    if (down) {\n      this.addClass('bt-button-down');\n    } else {\n      this.removeClass('bt-button-down');\n    }\n  }\n});\n\nfunction useClassName(use) {\n  if (use === 'special') {\n    return 'uiButtonSpecial';\n  } else {\n    return 'uiButtonConfirm';\n  }\n}\n\nexports.Button = Button;\n\n//@ sourceURL=bolt_touch/views/button\n});");

// module: bolt/compat/view
// file:   ../bolt/bolt/lib/compat/view.js
eval("define(\"bolt/compat/view\", function(require, exports, module) { /**\n * Copyright (c) 2011-2012, Facebook, Inc.\n * All rights reserved.\n *\n * @option preserve-header\n *\n * @deprecated Move to project specific folder\n */\n\nvar view = require('../view');\nvar View = view.View;\nvar TagView = require('../tag_view').TagView;\nvar util = require('../util');\n\nfunction deprecated(what, replacement) {\n  var msg = what + ' is deprecated.';\n  if (replacement) {\n    msg += '\\nUse ' + replacement + ' instead.';\n  }\n  var stack;\n  try { throw new Error(); } catch(e) { stack = e.stack; }\n  stack = '\\n' + (stack || '').replace(/.*\\n.*\\n/, '');\n  msg += ' Stack: ' + stack;\n  window.console && console.warn(msg);\n}\n\nTagView.prototype.setBoxOrientation = function(orientation) {\n  this.set('boxOrientation', orientation);\n  return this.setStyle({\n    'display': '-webkit-box',\n    'webkitBoxOrient': orientation\n  });\n};\n\nTagView.prototype.setFlex = function(flex) {\n  this.set('flex', flex);\n  return this.setStyle({'-webkit-box-flex': flex});\n};\n\n\nView.prototype.listen = View.prototype.addListener;\nView.prototype.stopListening = View.prototype.removeListener;\n\nView.prototype.getBoxOrientation = function() {\n  return this.get('boxOrientation');\n};\n\n/**\n * WEBKIT SPECIFIC\n * sets flexbox orientation onto the view\n * @param {String} orientation - vertical/horizontal\n *                 the flexbox orientation to use\n */\nView.prototype.setBoxOrientation = function(orientation) {\n  this.set('boxOrientation', orientation);\n  return this.setStyle({\n    'display': '-webkit-box',\n    'webkitBoxOrient': orientation\n  });\n};\n\nView.prototype.getFlex = function() {\n  return this.get('flex');\n};\n\n/**\n * WEBKIT SPECIFIC\n * set the box flex for a box child view\n */\nView.prototype.setFlex = function(flex) {\n  this.set('flex', flex);\n  return this.setStyle({'-webkit-box-flex': flex});\n};\n\nvar setup = View.prototype.setup;\nView.prototype.setup = function() {\n  if (!this.klass.cssClass) {\n    var classes = util.map(this.klass.inheritanceChain, function(k) {\n      return 'bt-' + util.hyphenate(k.klassName);\n    }).reverse();\n    this.klass.cssClass = classes.join(' ');\n  }\n  return setup.apply(this, arguments);\n};\n\n//@ sourceURL=bolt/compat/view\n});");

// module: bolt/builder
// file:   ../bolt/bolt/lib/builder.js
eval("define(\"bolt/builder\", function(require, exports, module) { /**\n *\n * Copyright (c) 2011-2012, Facebook, Inc.\n * All rights reserved.\n *\n * @option preserve-header\n *\n */\n\nvar util          = require('./util');\nvar core          = require('./core');\nvar ClassRegistry = core.ClassRegistry;\n\nvar Builder = core.createClass({\n  name: 'Builder',\n\n  build: function(configuration, owner) {\n    if (util.isArray(configuration)) {\n      var arr = [];\n      for (var i = 0, length = configuration.length; i < length; i++) {\n        arr.push(this._buildOne(configuration[i], owner));\n      }\n      return arr;\n    }\n    return this._buildOne(configuration, owner);\n  },\n\n  _buildOne: function(configuration, owner) {\n    /**\n     * Then the configuration was already built.\n     */\n    if (configuration.setup) {\n      return configuration;\n    }\n\n    /* If you specify a particular view class, that takes precedence, if you\n     * specify a tagName and no view class then we build an instance of TagView,\n     * with your specified tagName, otherwise we just build the view base class.\n     */\n    configuration.owner = configuration.owner || owner;\n    var viewConstructor = this._resolveViewConstructor(configuration);\n    return new viewConstructor(configuration);\n  },\n\n  _resolveViewConstructor: function(configuration) {\n    var providedView = configuration.view;\n    /* By default, if you don't provide a view name, we'll make a tag view, and\n     * if you provided a tagName, we'll use that - otherwise default to div.\n     */\n    if (!providedView) {\n      return require('./tag_view').TagView;\n    } else {\n      /* This is a bit nuanced. We obtain 'View' from the class registry because\n       * different stacks may alias 'View' to be a custom view that has\n       * additional capabilities (such as layouts etc.). Aliasing in general is\n       * discouraged - but in the case of Views, it's so core that it might make\n       * sense to allow it.\n       */\n      return util.isFunction(providedView) ?\n        providedView :\n        ClassRegistry[providedView];\n    }\n  }\n});\n\nvar builder = new Builder();\n\nexports.build = function(configuration, owner) {\n  return builder.build(configuration, owner);\n};\n\nexports.setBuilder = function(customBuilder) {\n  builder = customBuilder;\n};\n\nexports.Builder = Builder;\n\n//@ sourceURL=bolt/builder\n});");

// module: bolt/tag_view
// file:   ../bolt/bolt/lib/tag_view.js
eval("define(\"bolt/tag_view\", function(require, exports, module) { /**\n * Copyright (c) 2011-2012, Facebook, Inc.\n * All rights reserved.\n *\n * @option preserve-header\n *\n */\n\nvar util     = require('./util');\nvar core     = require('./core');\nvar dom      = require('./dom');\n\nvar Container = require('./mixins/container').Container;\nvar Responder = require('./mixins/responder').Responder;\n\n/**\n * A special (final) class that should be private to the builder. Noone should\n * ever need to instantiate an instance of TagView except the builder. View\n * classes in general do not need to delegate html attributes to the container\n * node, because many of them just don't make sense from the perspective of a\n * general container component. However a TagView is a container component that\n * is intended to be treated as a lower level building block in a build paln, or\n * declare() statement, so control over all attributes is important.\n */\n\nvar TagView = exports.TagView = core.createClass({\n\n  name: 'TagView',\n\n  mixins: [Responder, Container],\n\n  /**\n   * Accepts options and tagName. Usually tagName will be in the options, but\n   * if you're allocating a TagView, you likely allready found the tagName -\n   * pass it in so we don't need to look it up again.\n   */\n  construct: function(options) {\n    options = options || {};\n    this.setNode(dom.createElement(options.tagName || 'div'));\n    this.setup(options);\n  },\n\n  setName: function(name) {\n    this._node.name = name;\n    return this;\n  },\n  getName: function() {\n    return this._node.name;\n  },\n  setHref: function(href) {\n    this._node.href = href;\n    return this;\n  },\n  getHref: function() {\n    return this._node.href;\n  },\n  setId: function(id) {\n    this._node.id = id;\n    return this;\n  },\n  getId: function() {\n    return this._node.id;\n  },\n  setTagName: function(tagName) {\n    // Do nothing - just make sure noone tries to set a tag name on a dom node\n    // directly - causing an error in IE.\n    return this;\n  },\n  getTagName: function() {\n    return this._node.tagName;\n  },\n\n  delegateProperties: {\n    node: [\n      'disabled',\n      'id',\n      'tabIndex',\n      'src',\n      'cellpadding',\n      'cellspacing',\n      'htmlFor',\n      'colspan',\n      'rowspan',\n\n      // Just in case someone uses additionalClasses on a tag view, expecting\n      // it to gracefully append a className. In the case of tag views, there's\n      // nothing to gracefully append to so we just set the class.\n      { name: 'className', alias: 'additionalClasses'}\n    ],\n    style: [\n      'height',\n      'width'\n    ]\n  }\n\n});\n\n\n//@ sourceURL=bolt/tag_view\n});");

// module: bolt/dom/feature_detect
// file:   ../bolt/bolt/lib/dom/feature_detect.js
eval("define(\"bolt/dom/feature_detect\", function(require, exports, module) { // some code borrowed from Modernizr (www.modernizr.com)\n\nvar cssPrefixes = ['Webkit', 'Moz', 'O', 'ms'];\n\n/*\n * Use a element with custom tag for feature detection.\n */\nvar elem;\nfunction getElem() {\n  if (!elem) {\n    elem = document.createElement('boltfeaturetester');\n  }\n  return elem;\n}\n\nfunction getStyleObj() {\n  return getElem().style;\n}\n\n/**\n * Browser specific CSS properties are prefixed.  For example, the transition\n * CSS property appears as WebkitTransition in Chrome and Safari, MozTransition\n * in Firefox, OTransition in Opera, msTransition on IE, and transition on\n * future browsers when it's a standard.\n *\n * @param  {String} prop property to look for\n * @return {String} prefixed property, or false if not available\n */\nfunction prefixedCSS(prop) {\n  // prefixed properties begin with uppercase\n  var ucProp = prop.charAt(0).toUpperCase() + prop.substr(1);\n  var props = new Array(cssPrefixes.length + 1);\n  // first check the raw property\n  props[0] = prop;\n  // then check all property prefixes\n  for (var i = 1; i <= cssPrefixes.length; i++) {\n    props[i] = cssPrefixes[i - 1] + ucProp;\n  }\n  var style = getStyleObj();\n  for (var i = 0; i < props.length; i++) {\n    if (typeof(style[props[i]]) !== 'undefined') {\n      return props[i];\n    }\n  }\n  return false;\n}\n\n/**\n * Browser specific events can be detected by checking for prefixed CSS\n * properties.  For compatibility reasons, eventName should be camelcased; it\n * will automatically be lowercased when necessary.\n *\n * TODO: This function is only verified with transition and animation events;\n * make sure it works in all other cases too.\n */\nfunction prefixedEvent(cssProp, eventName) {\n  // make first letter uppercase for camelcasing\n  var ucEventName = eventName.charAt(0).toUpperCase() + eventName.substr(1);\n  var prefixedProp = prefixedCSS(cssProp);\n  var prefix = prefixedProp &&\n    prefixedProp.slice(0, -cssProp.length).toLowerCase();\n  switch (prefix) {\n    case '':\n      // unprefixed event should be supported\n      return eventName.toLowerCase();\n    case 'webkit':\n      // Webkit uses CamelCase\n      return 'webkit' + ucEventName;\n    case 'moz':\n      // Firefox doesn't prefix events\n      return eventName.toLowerCase();\n    case 'o':\n      // Opera uses lowercase in version >=12, CamelCase in <=11?\n      // let's just support newest version\n      return 'o' + eventName.toLowerCase();\n    case 'ms':\n      // IE does camelcase weirdly, because it prefixes with MS instead of ms\n      return 'MS' + ucEventName;\n    default:\n      return false;\n  }\n}\n\nexports.prefixedCSS = prefixedCSS;\nexports.prefixedEvent = prefixedEvent;\n\n//@ sourceURL=bolt/dom/feature_detect\n});");

// module: bolt_touch/mixins/touchable
// file:   ../bolt/bolt_touch/lib/mixins/touchable.js
eval("define(\"bolt_touch/mixins/touchable\", function(require, exports, module) { var View = require('../view').View;\nvar dom = require('bolt/dom');\nvar util = require('bolt/util');\n\nvar touchClassName = 'touched';\n\nfunction hasMovedPastLimit(start, end, limit) {\n  var xDiff = start.x - end.pageX;\n  var yDiff = start.y - end.pageY;\n  var dist = Math.sqrt((xDiff * xDiff) + (yDiff * yDiff));\n\n  return dist > limit;\n}\n\nvar Touchable = {\n\n  properties: {\n    isTouchable: true,\n    // maximum distance, in pixels, a user can move before the action\n    // is no longer considered a \"touch\"\n    touchLimit: 30\n  },\n\n  onMousedown: function(event) {\n    if (!View.hasTouch) {\n      return this.onTouchstart(event);\n    }\n  },\n\n  onTouchstart: function(event) {\n    if (!this.getIsTouchable()) {\n      return;\n    }\n\n    event = event.touches ? event.touches[0] : event;\n\n    var target = this.getNode();\n    this.__touched = {\n      x: event.pageX,\n      y: event.pageY,\n      target: target\n    };\n    this.__moved = false;\n\n    dom.addClass(this.getNode(), touchClassName);\n  },\n\n  onMousemove: function(event) {\n    if (!View.hasTouch) {\n      return this.onTouchmove(event);\n    }\n  },\n\n  onTouchmove: function(event) {\n    var touch;\n\n    if (!this.getIsTouchable()) {\n      return;\n    }\n\n    if (this.__touched && !this.__moved) {\n      touch = event.touches ? event.touches[0] : event;\n\n      if (hasMovedPastLimit(this.__touched, touch, this.get('touchLimit'))) {\n        this.__moved = true;\n        dom.removeClass(this.getNode(), touchClassName);\n      }\n    }\n  },\n\n  onMouseup: function(event) {\n    if (!View.hasTouch) {\n      return this.onTouchend(event);\n    }\n  },\n\n  onTouchend: function(event) {\n    var touch, isPastLimit;\n\n    if (!this.getIsTouchable()) {\n      return;\n    }\n    if (this.__touched) {\n      touch = event.changedTouches ? event.changedTouches[0] : event;\n      isPastLimit = hasMovedPastLimit(this.__touched, touch, this.get('touchLimit'));\n\n      if (this.__moved || isPastLimit) {\n        dom.removeClass(this.getNode(), touchClassName);\n        this.hasFinishedTouching(false, event);\n      } else {\n        this.hasFinishedTouching(true, event);\n        dom.removeClass(this.getNode(), touchClassName);\n      }\n    }\n\n    this.__touched = null;\n    this.__moved = false;\n  },\n\n  onTouchcancel: function(event) {\n    if (!this.getIsTouchable()) {\n      return;\n    }\n    if (this.__touched) {\n      dom.removeClass(this.getNode(), touchClassName);\n      this.hasFinishedTouching(false, event);\n    }\n    this.__touched = null;\n    this.__moved = false;\n  },\n\n  /**\n   * Delegate method, calld when the user is done touching the element.\n   *\n   * @param {Boolean} whether the element has been touched\n   * @param {Object} the touchend event\n   */\n  hasFinishedTouching: function(wasTouched, event) { }\n};\n\nexports.Touchable = Touchable;\n\n//@ sourceURL=bolt_touch/mixins/touchable\n});");

// module: bolt/mixins/can_delegate_properties
// file:   ../bolt/bolt/lib/mixins/can_delegate_properties.js
eval("define(\"bolt/mixins/can_delegate_properties\", function(require, exports, module) { var util = require('../util');\n\n/**\n * CanDelegateProperties allows classes to declaritvely describe which\n * properties of a class's property should be lifted to be top level properties\n * of (the aforementioned) class.\n *\n * There are two ways of using CanDelegateProperties. One is to simply lift a\n * property's properties and the other to lift and alias.\n *\n * @example\n *\n * var Foo = core.createClass({\n *\n *   name: 'Foo',\n *\n *   properties: {\n *     topLevelProperty1: null,\n *     topLevelProperty2: null\n *   },\n *\n *   delegateProperties: {\n *     topLevelProperty1: ['secondLevelPropertyThatWillBeLifted1']\n *     topLevelProperty2:\n *       [{name: 'secondLevelPropertyThatWillBeLifted1, alias:'newName'}]\n *   }\n * });\n */\nvar CanDelegateProperties = exports.CanDelegateProperties = {\n\n  classExtended: function(klass, config) {\n    addDelegateProperties(klass, config);\n  },\n\n  mixinIncluded: function(klass, config) {\n    addDelegateProperties(klass, config);\n  }\n};\n\nfunction generateDelegateSetter(target, setValue, name, getTarget) {\n  return function(value) {\n    // Support both getting a value directly from the refs\n    // object created by the builder, and from a target with a\n    // defined getter\n    var obj = (this.findRef ? this.findRef(target) : null) || this[getTarget]();\n    if (obj[setValue]) {\n      obj[setValue](value);\n    } else {\n      if (value !== undefined) {\n        obj[name.name || name] = value;\n      }\n    }\n    return this;\n  };\n}\n\nfunction generateDelegateGetter(target, getValue, name, getTarget) {\n  return function() {\n    /* We check for a getter first, because not all classes will have a\n     * member called findRef - we could take reference to findRef out of\n     * core.js */\n    var obj = (this.findRef ? this.findRef(target) : null) || this[getTarget]();\n    return obj[getValue] ? obj[getValue]() : obj[name.name || name];\n  };\n}\n\nfunction addDelegateProperties(klass, config) {\n  if (!config.delegateProperties) {\n    return;\n  }\n  var delegateProperties = config.delegateProperties;\n\n  var proto = klass.prototype;\n\n  var names;\n  for (var target in delegateProperties) {\n    names = delegateProperties[target];\n    var name;\n    for (var i = 0; i < names.length; i++) {\n      name = names[i];\n      if (target === (name.alias || name)) {\n        window.console && console.warn('Do not give a delegateProperty target and property (or ' +\n          'property alias) the same name. Fix delegateProperty \"' + target +\n          '\" in class \"' + klass.klassName + '\".');\n      }\n      var aliasSetValue  = util.setter(name.alias || name);\n      var aliasGetValue  = util.getter(name.alias || name);\n\n      var getTarget = util.getter(target);\n      // Support both simple string names and objects of the\n      // form {alias: 'src name', name: 'target name'}, e.g.\n      // {alias: 'content', name: 'innerHTML'}\n      var setValue = util.setter(name.name || name);\n      var getValue = util.getter(name.name || name);\n      if (!proto.hasOwnProperty(aliasSetValue)) {\n        proto[aliasSetValue] = generateDelegateSetter(target, setValue, name, getTarget);\n      }\n\n      if (!proto.hasOwnProperty(aliasGetValue)) {\n        proto[aliasGetValue] = generateDelegateGetter(target, getValue, name, getTarget);\n      }\n    }\n  }\n}\n\n//@ sourceURL=bolt/mixins/can_delegate_properties\n});");

// module: bolt/dom/event
// file:   ../bolt/bolt/lib/dom/event.js
eval("define(\"bolt/dom/event\", function(require, exports, module) { /**\n *\n * Copyright (c) 2011-2012, Facebook, Inc.\n * All rights reserved.\n *\n * @preserve-header\n *\n */\n\n/*globals Event */\n\n'use strict';\n\nvar core = require('../core');\n\n// Since we wrap the raw browser events,\n// we still want to have easy access to\n// common properties directly. These properties\n// get copied onto the wrapper automatically.\nvar copyKeys = [\n  'type',\n  'target',\n  'keyCode',\n  'targetView',\n  'touches',\n  'targetTouches',\n  'changedTouches',\n  'clientX',\n  'clientY',\n  'pageX',\n  'pageY'\n];\nvar copyKeysLength = copyKeys.length;\n\nfunction EventShim() {\n  // EventShim tracks the views through which it bubbles,\n  // and maintains a list of refs so that a View owner can\n  // invoke event listeners\n  this.refs = [];\n}\n\nEventShim.prototype = {\n\n  isBoltEvent: true,\n\n  originalEvent: null,\n\n  refCount: 0,\n\n  defaultPrevented: false,\n\n  preventDefault: function() {\n    if (this.originalEvent.preventDefault) {\n      this.originalEvent.preventDefault();\n    } else {\n      this.originalEvent.returnValue = false;\n    }\n    this.defaultPrevented = true;\n  },\n\n  propagationStopped: false,\n\n  stopPropagation: function() {\n    if (this.originalEvent.stopPropagation) {\n      this.originalEvent.stopPropagation();\n    } else {\n      this.originalEvent.cancelBubble = true;\n    }\n    this.propagationStopped = true;\n  }\n\n};\n\nfunction normalize(e) {\n  // Fix target property, if necessary\n  if (!e.target) {\n    e.target = e.srcElement || document;\n  }\n\n  // check if target is a textnode (safari)\n  if (e.target.nodeType === 3) {\n    e.target = e.target.parentNode;\n  }\n\n  // Add relatedTarget, if necessary\n  if (!e.relatedTarget && e.fromElement) {\n    e.relatedTarget = e.fromElement === e.target ? e.toElement : e.fromElement;\n  }\n\n  // Calculate pageX/Y if missing and clientX/Y available\n  if (e.pageX == null && e.clientX != null) {\n    var doc = document;\n    var body = doc.body;\n\n    e.pageX = e.clientX +\n      (doc && doc.scrollLeft || body && body.scrollLeft || 0) -\n      (doc && doc.clientLeft || body && body.clientLeft || 0);\n    e.pageY = e.clientY +\n      (doc && doc.scrollTop  || body && body.scrollTop  || 0) -\n      (doc && doc.clientTop  || body && body.clientTop  || 0);\n  }\n\n  // Add which for key events\n  if (e.which == null && (e.charCode != null || e.keyCode != null)) {\n    e.which = e.charCode != null ? e.charCode : e.keyCode;\n  }\n\n  // Add metaKey to non-Mac browsers (use ctrl for PC's and Meta for Macs)\n  if (e.metaKey === undefined) {\n    e.metaKey = e.metaKey || e.ctrlKey;\n  }\n\n  // Add which for click: 1 === left; 2 === middle; 3 === right\n  // Note: button is not normalized, so don't use it\n  if (!e.which && e.button !== undefined) {\n    e.which = (e.button & 1 ? 1 :\n              (e.button & 2 ? 3 :\n              (e.button & 4 ? 2 : 0 )));\n  }\n\n  return e;\n}\n\nfunction resetEvent(event, browserEvent) {\n  var idx, key;\n\n  // Test if it's an event on non-IE and on IE.\n  if ((window.Event && browserEvent instanceof window.Event) ||\n      (browserEvent.srcElement)) {\n    browserEvent = normalize(browserEvent);\n  }\n\n  event.originalEvent = browserEvent;\n  event.propagationStopped = false;\n  event.defaultPrevented = false;\n  event.refCount = 0;\n\n  for (idx = 0; idx < copyKeysLength; idx += 1) {\n    key = copyKeys[idx];\n    event[key] = browserEvent[key];\n  }\n}\n\nexports.EventShim = EventShim;\nexports.resetEvent = resetEvent;\n\n//@ sourceURL=bolt/dom/event\n});");

// module: lib/sample-view/index
// file:   lib/sample-view/index.js
eval("define(\"lib/sample-view/index\", function(require, exports, module) { // this is a \"directory module\" that can be referenced by its directory name\n// so you can just do require('sample-view')\nvar core = require('bolt/core');\nvar View = require('bolt/view').View;\nvar Button  = require('bolt_touch/views/button').Button;\n\nexports.SampleView = core.createClass({\n  name: 'SampleView',\n  extend: View,\n  declare: function(options) {\n    return {\n      content: \"hello world! 3\"\n    };\n  }\n});\n\nvar ButtonExample = core.createClass({\n  extend: View,\n\n  properties: {\n    secondButtonValue: null // defines setSecondValue()\n  },\n\n  construct: function(options) {\n    this.firstButtonValue = \"First Button\";\n    View.call(this, options);\n    this.setSecondButtonValue(\"Second Button\");\n  },\n\n  declare: function(options) {\n    return{\n      childViews: [\n        {\n          view: Button,\n          value: 'Example Button 1',\n          ref: 'buttonOne'\n        },\n        {\n          view: Button,\n          value: 'Example Button 2',\n          ref: 'buttonTwo'\n        }\n      ]\n    }\n  },\n\n  ready: function() {\n    this.buttonone = this.refs.buttonone;\n    this.buttontwo = this.findRef('buttontwo');\n  },\n\n  onButtonOneClick: function() {\n    this.buttonone.setValue(this.firstButtonValue);\n  },\n\n  onButtonTwoClick: function() {\n    this.buttontwo.setValue(this.getSecondButtonValue());\n  }\n})\n\nvar builder = require('bolt/builder');\n\nvar myButton = builder.build({\n    // Define the type of view to build\n    view: Button,\n    // Set the initial value of the 'value' property\n    value: 'Click Me',\n    // Define an action to perform when this button is clicked or tapped.\n    action: function(button, event) {\n      alert('You clicked the button with the value ' + button.getValue());\n    }\n});\n\n// Define a new view called MyPaneLayout\nvar MyPaneLayout = core.createClass({\n  name: 'MyPaneLayout',\n  extend: View,\n  boxOrientation: 'vertical',\n\n  declare: function() {\n    // Call the setLayout function, which uses the builder to create\n    // it's sub views\n    return {\n      childViews: [\n        {\n          className: 'header',\n          content: 'Choose A Pane'\n        },\n        {\n          // Define a horizontally laid out container with two buttons\n          boxOrientation: 'horizontal',\n          childViews: [\n            // Create two buttons.  Note how the 'action' is bound to\n            // 'onSelectPane'.  Because the 'MyPaneLayout' view is creating\n            // the Button, a listener can be added to the Button as a\n            // string telling it the name of the funtion on the Buttons\n            // owner to call\n            {\n              view: Button,\n              value: 'Pane 1',\n              action: 'onSelectPane'\n            },\n            {\n              view: Button,\n              value: 'Pane 2',\n              action: 'onSelectPane'\n            }\n          ]\n        },\n        // Define the two panes which will be shown/hidden when a button\n        // is clicked.  Since no view type or tagName is provided, these\n        // default to being simple DIV elements\n        {\n          ref: 'pane1',\n          style: {\n            height: '200px',\n            backgroundColor: '#bbb'\n          },\n          content: 'This is Pane 1'\n        },\n        {\n          ref: 'pane2',\n          style: {\n            height: '200px',\n            backgroundColor: '#333',\n            color: 'white',\n            display: 'none'\n          },\n          content: 'This is Pane 2'\n        }\n      ]\n    };\n  },\n\n  onSelectPane: function(button, event) {\n    var value = button.getValue();\n\n    // Check which button was clicked, and show/hide the\n    // the panes\n    if (value == 'Pane 1') {\n      this.findRef('pane1').setStyle({display: ''});\n      this.findRef('pane2').setStyle({display: 'none'});\n    } else {\n      this.findRef('pane1').setStyle({display: 'none'});\n      this.findRef('pane2').setStyle({display: ''});\n    }\n  }\n});\n\nvar context = {\n  handleClick: function(event) {\n    console.log('Button was clicked: ', event);\n  }\n};\nmyButton.addListener('click', 'handleClick', context);\n\nvar MyOnClickView = core.createClass({\n  name : 'MyView',\n  extend: View,\n  declare: function() {\n    return {\n      content: \"OnClick View\"\n    };\n  },\n  // Handler for the touch start event\n  onClick: function(event) {\n    alert('I was clicked!');\n  }\n});\n\nvar MyOwnerView = core.createClass({\n  name : 'MyOwnerView',\n  extend: View,\n  declare: function() {\n    return {\n      childViews: [\n        {\n          content: \"MyOwnerView Inner View\",\n          ref: \"myInnerView\"\n        }\n      ]\n    };\n  },\n  // Handler for the touch start event\n  onMyInnerViewMousedown: function(event) {\n    this.refs.myInnerView.setContent(\"Mouse Down!!\");\n  },\n\n  onMyInnerViewMouseup: function(event) {\n    this.refs.myInnerView.setContent(\"no more clicky click :(\");\n  },\n\n// Handler for the touch start event\n  onMyInnerViewTouchstart: function(event) {\n    this.refs.myInnerView.setContent(\"That tickles!!\");\n  },\n\n  // Handler for the touch end event\n  onMyInnerViewTouchend: function(event) {\n    this.refs.myInnerView.setContent(\"Touch me again and I'll .....\");\n  }\n});\n\nexports.init = function() {\n  // Instantiate a new instance of a MyPaneLayout view\n  // and put it in the document body\n  new MyPaneLayout().placeIn(document.body);\n  // new exports.SampleView({}).placeIn(document.body);\n  myButton.placeIn(document.body);\n  new ButtonExample().placeIn(document.body);\n  new MyOnClickView().placeIn(document.body);\n  new MyOwnerView().placeIn(document.body);\n}\n//@ sourceURL=lib/sample-view\n});");

// module: bolt/event_dispatcher
// file:   ../bolt/bolt/lib/event_dispatcher.js
eval("define(\"bolt/event_dispatcher\", function(require, exports, module) { /**\n *\n * Copyright (c) 2011-2012, Facebook, Inc.\n * All rights reserved.\n *\n * @preserve-header\n *\n */\n\n'use strict';\n\nvar util = require('./util');\nvar core = require('./core');\n\nvar domEvents = {\n  'animationend': true,\n  'animationiteration': true,\n  'animationstart': true,\n  'blur': true,\n  'change': true,\n  'click': true,\n  'dblclick': true,\n  'drag': true,\n  'dragend': true,\n  'dragenter': true,\n  'dragleave': true,\n  'dragover': true,\n  'dragstart': true,\n  'drop': true,\n  'error': true,\n  'focus': true,\n  'focusin': true,\n  'focusout': true,\n  'input': true,\n  'keydown': true,\n  'keypress': true,\n  'keyup': true,\n  'load': true,\n  'mousedown': true,\n  'mouseenter': true,\n  'mouseleave': true,\n  'mousemove': true,\n  'mouseout': true,\n  'mouseover': true,\n  'mouseup': true,\n  'resize': true,\n  'scroll': true,\n  'select': true,\n  'submit': true,\n  'touchcancel': true,\n  'touchend': true,\n  'touchmove': true,\n  'touchstart': true,\n  'transitionend': true\n};\n\n/**\n * @class\n *\n * EventDispatcher manages the application-scoped event responding and\n * dispatching. It uses id-based delegation to find the proper view to\n * send the event to, and attaches/responds toevents listeners on the\n * root element.\n */\nvar EventDispatcher = core.createClass({\n\n  name: 'EventDispatcher',\n\n  // ..........................................................\n  // Public\n  //\n\n  properties: {\n    root: null\n  },\n\n  setRoot: function(value) {\n    var currentRoot = this.get('root');\n    if (currentRoot) {\n      this._teardown(currentRoot);\n    }\n\n    this.set('root', value);\n    if (value) {\n      this._setup(value);\n    }\n  },\n\n  becomeFirstResponder: function(newResponder) {\n    var currentResponder = this._firstResponder;\n\n    if (currentResponder && currentResponder.willLoseFirstResponder) {\n      currentResponder.willLoseFirstResponder();\n    }\n\n    this._firstResponder = newResponder;\n  },\n\n  releaseFirstResponder: function(object) {\n    var currentResponder = this._firstResponder;\n\n    if (currentResponder !== object) {\n      return;\n    }\n\n    if (currentResponder && currentResponder.willLoseFirstResponder) {\n      currentResponder.willLoseFirstResponder();\n    }\n\n    this._firstResponder = null;\n  },\n\n  isDomEvent: function(eventName) {\n    return !!this._events[eventName];\n  },\n\n  // ..........................................................\n  // Protected\n  //\n\n  construct: function(domLibrary, events) {\n    this._domLibrary = domLibrary;\n    this._events = events || domEvents;\n    this._handler = util.bind(this._handler, this);\n  },\n\n  destroy: function() {\n    var root = this.getRoot();\n    if (root) {\n      this._teardown(root);\n    }\n  },\n\n\n\n  // ..........................................................\n  // Private\n  //\n\n  _domLibrary: null,\n  _events: null,\n  _firstResponder: null,\n\n  /** @private */\n  _bubbleEvent: function(view, event) {\n    var eventDispatcher = view.getEventDispatcher ? view.getEventDispatcher() : this;\n\n    var owner = view.getOwner && view.getOwner();\n    var ref;\n    var refCount = 0;\n\n    while (view && !event.propagationStopped && eventDispatcher === this) {\n      if (view.sendEvent) {\n        // Only pass the refs through to sendEvent if it is the owner of the\n        // views referred to in the refs array.\n        event.refCount = (view === owner ? refCount : 0);\n        view.sendEvent(event);\n      }\n\n      if (view && owner && view === owner) {\n        // If moving up through the hierarchy of views, we reach the owner,\n        // clear all refs that have been recorded and start recording them\n        // again.  This ensures that a view is not passed a ref\n        // of something it doesn't own.\n        owner = view.getOwner && view.getOwner();\n        refCount = 0;\n      }\n\n      ref = view.getRef && view.getRef();\n      if (ref) {\n        event.refs[refCount] = ref;\n        refCount += 1;\n      }\n\n      if (view.getNextResponder) {\n        view = view.getNextResponder();\n      } else {\n        view = view.getParentView();\n      }\n      eventDispatcher = view && view.getEventDispatcher();\n    }\n  },\n\n  _doesBubble: function(eventType) {\n    switch (eventType) {\n      case 'focus':\n      case 'blur':\n      case 'load':\n      case 'unload':\n        return false;\n      default:\n        return true;\n    }\n  },\n\n  _handler: function(event) {\n    var node = event.target;\n    var view = this._targetViewForNode(node);\n    var firstResponder = this._firstResponder;\n\n    if (view) {\n      event.targetView = view;\n\n      if (firstResponder) {\n        firstResponder.sendEvent(event);\n        event.stopPropagation();\n      } else {\n        this._bubbleEvent(view, event);\n      }\n    }\n\n    return event.propagationStopped;\n  },\n\n  _setup: function(options) {\n    var events = this._events;\n    var domLibrary = this._domLibrary;\n    var root = this.getRoot();\n    var handler = this._handler;\n    var eventName;\n\n    for (eventName in events) {\n      if (this._doesBubble(eventName) && events.hasOwnProperty(eventName)) {\n        domLibrary.addListener(root, eventName, handler);\n      }\n    }\n  },\n\n  _teardown: function(rootElement) {\n    var events = this._events;\n    var domLibrary = this._domLibrary;\n    var handler = this._handler;\n    var eventName;\n\n    for (eventName in events) {\n      if (events[eventName]) {\n        domLibrary.removeListener(rootElement, eventName, handler);\n      }\n    }\n  },\n\n  _targetViewForNode: function(node) {\n    var domLibrary = this._domLibrary;\n    var view = domLibrary.getData(node, 'view');\n\n    // if you interact with a nested dom node that isn't a view,\n    // start the event bubbling at the closest view.\n    while (node && !view) {\n      node = node.parentNode;\n      if (node) {\n        view = domLibrary.getData(node, 'view');\n      }\n    }\n\n    return view;\n  }\n});\n\nvar eventDispatcher;\nfunction getInstance() {\n  if (!eventDispatcher) {\n    var dom = require('./dom');\n    eventDispatcher = new EventDispatcher(dom, domEvents);\n    eventDispatcher.setRoot(document);\n  }\n  return eventDispatcher;\n}\n\nexports.EventDispatcher = EventDispatcher;\nexports.getInstance = getInstance;\n\n//@ sourceURL=bolt/event_dispatcher\n});");

// module: bolt/util
// file:   ../bolt/bolt/lib/util.js
eval("define(\"bolt/util\", function(require, exports, module) { /**\n * Copyright (c) 2011-2012, Facebook, Inc.\n * All rights reserved.\n *\n * @option preserve-header\n *\n */\n\nmodule.exports = exports = require('./vendor/_');\n\nvar _cid = 1;\n\nvar createTransformer = function(prefix) {\n  var names = {};\n  return function(name) {\n    if (!names[name]) {\n      names[name] = prefix + exports.capitalize(name);\n    }\n    return names[name];\n  };\n};\n\nexports.setter = createTransformer('set');\nexports.getter = createTransformer('get');\nexports.eventHandler = createTransformer('on');\n\nvar slice = Array.prototype.slice;\n\n/**\n * Generates a setter for a property that directly manipulates a CSS class.\n *\n * For a button consider the following properties declaration:\n *\n *   properties: {\n *     color: null,\n *     enabled: null,\n *   }\n *\n * Then to have those properties directly manipulate CSS classes the setters\n * should be overriden as follows:\n *\n *   setColor: util.modeSetter('color', ['green', 'red', 'blue']),\n *   setEnabled: util.modeSetter('enabled')\n *\n * @param mode - the property name\n * @param classes - If this is a boolean property (where truthy values will add\n *    <mode> to the className of the object and falsy values will remove <mode>\n *    from the className) then do not pass in a second argument. If this is a\n *    enumerated property with several mutually excluded options include an\n *    array of string options for what those properties may be. When one gets\n *    set the others get unset and a generated class is added to the classname\n *    of the form <mode>-<value>. If a value that isn't in the enumerated values\n *    is passed in, an exception is thrown.\n *\n * NOTE: Currently properties do not call their setter on construction so\n *  to set a default value, you'll need to call the setter in the ready\n *  function.\n */\nexports.modeSetter = function(mode, classes, refName) {\n  if (exports.isBlank(classes)) {\n    // toggle mode\n    return function(value) {\n      var ref = this;\n      if (refName) {\n        ref = this.findRef(refName);\n      }\n      this.set(mode, !!value);\n      return ref.toggleClass(mode, value);\n    };\n  } else {\n    // enum mode\n    var classesHash = {};\n    for (var i = 0; i < classes.length; i++) {\n      classesHash[classes[i]] = true;\n    }\n    return function(value) {\n      var ref = this;\n      if (refName) {\n        ref = this.findRef(refName);\n      }\n      if (!(value in classesHash)) {\n        throw this.getDeclaredClass() + ' does not support value \"' +\n          value + '\" for mode \"' + mode + '\".';\n      }\n      this.set(mode, value);\n      ref.setMode(mode, value);\n    };\n  }\n};\n\nexports.bind = function(func, obj) {\n  var args = slice.call(arguments, 2);\n  var nativeBind = Function.prototype.bind;\n\n  if (typeof func === \"string\") {\n    return function() {\n      return obj[func].apply(obj, args.concat(slice.call(arguments)));\n    };\n  } else {\n    if (func.bind === nativeBind && nativeBind) {\n      return nativeBind.apply(func, slice.call(arguments, 1));\n    }\n    return function() {\n      return func.apply(obj, args.concat(slice.call(arguments)));\n    };\n  }\n};\n\n/**\n * Generates a lowercase slug using the provided separator\n * Will try to figure out what \"words\" are in a cased name, and will\n * return a separator-divided string of those words in lowercase\n * @example\n *   stringTransform('ClassCasedName', '-')   == 'class-cased-name'\n *   stringTransform('DOMContentLoaded', '-') == 'dom-content-loaded'\n *   stringTransform('abcDEF', '-')           == 'abc-def'\n *   stringTransform('ABCdef', '-')           == 'ab-cdef'\n *   stringTransform('AbC-def', '-')          == 'ab-c-def'\n *   stringTransform('abc--def', '-')         == 'abc-def'\n */\nvar _stringTransformUpThenDown = /(.)([A-Z])([^A-Z])/g;\nvar _stringTransformDownThenUp = /([^A-Z])([A-Z])/g;\nvar _stringTransformNonStandard = /[^A-Za-z0-9]+/g;\nvar stringTransform = function(str, separator) {\n  str = str.replace(_stringTransformUpThenDown, '$1' + separator + '$2$3');\n  str = str.replace(_stringTransformDownThenUp, '$1' + separator + '$2');\n  str = str.replace(_stringTransformNonStandard, separator);\n  return str.toLowerCase();\n};\n\nexports.hyphenate = function(str) {\n  return stringTransform(str, '-');\n};\n\nexports.underscore = function(str) {\n  return stringTransform(str, '_');\n};\n\nexports.trim = String.prototype.trim ?\n  function(str){ return str.trim(); } :\n  function(str){ return str.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');};\n\nexports.capitalize = function(value) {\n  if (!value || !value.length) {\n    return value;\n  }\n  return value.charAt(0).toUpperCase() + value.slice(1);\n};\n\n/**\n * Call a method on multiple contexts.\n * This is similar to util.invoke, but is more lightweight. Whereas\n * util.invoke builds an object with the return values of all the\n * function calls, util.run simply executes the functions and returns\n * nothing. This uses less memory and has one less function call.\n *\n * @param obj An array of contexts, each of which contains the method\n * @param method Either a function, or the string name of a function\n * in the context\n*/\nexports.run = function(obj, method) {\n  var args = arguments.length > 2 ? slice.call(arguments, 2) : [];\n  var context;\n  for (var i = 0; i < obj.length; i++) {\n    context = obj[i];\n    (method.call ? method || context : context[method]).apply(context, args);\n  }\n};\n\n/**\n * Extend an object with the properties on one or more objects.\n * The first parameter is the destination object into which properties\n * are copied.  All subsequent parameters are iterated over and all their\n * properties copied into the first parameter.\n *\n * @param obj The destination object into which properties are placed.\n */\nexports.extend = function(obj) {\n  var len = arguments.length;\n  var source;\n  var prop;\n  for (var i = 1; i < len; i++) {\n    source = arguments[i];\n    for (prop in source) {\n      if (source[prop] !== void 0) {\n        obj[prop] = source[prop];\n      }\n    }\n  }\n  return obj;\n};\n\nvar CHARS =\n  '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split('');\n\nexports.generateUUID = function() {\n  var uuid = new Array(36),\n      rnd = 0,\n      r;\n  for (var i = 0; i < 36; i++) {\n    if (i == 8 || i == 13 || i == 18 || i == 23) {\n      uuid[i] = '-';\n    } else if (i == 14) {\n      uuid[i] = '4';\n    } else {\n      if (rnd <= 0x02) rnd = 0x2000000 + (Math.random() * 0x1000000) | 0;\n      r = rnd & 0xf;\n      rnd = rnd >> 4;\n      uuid[i] = CHARS[(i == 19) ? (r & 0x3) | 0x8 : r];\n    }\n  }\n  return uuid.join('');\n};\n\n/**\n * Used to create an identifier that is intended to be unique per page load.\n * Do not persist this id and expect it to be unique in any offline system.\n */\nexports.generateCID = function() {\n  return _cid++;\n};\n\nexports.isBlank = function(obj) {\n  return exports.isUndefined(obj) ||\n    exports.isNull(obj) ||\n    (!exports.isNumber(obj) && exports.isEmpty(obj));\n};\n\nexports.defineProperty = function(obj, key, descriptor) {\n  if (!Object.defineProperty) {\n    // herp derp, this should never have to be run amirite\n    obj.key = descriptor.value;\n  }\n\n  Object.defineProperty(obj, key, descriptor);\n};\n\n//@ sourceURL=bolt/util\n});");

// module: bolt/core
// file:   ../bolt/bolt/lib/core.js
eval("define(\"bolt/core\", function(require, exports, module) { /**\n * Copyright (c) 2011-2012, Facebook, Inc.\n * All rights reserved.\n *\n * @option preserve-header\n *\n */\n\nvar util = require('./util');\n\n// prefix for storing properties on the object. This is a holdover from Javelin.\nvar PROP_PREFIX = '__auto__';\n\n// these keys are handled specially and are not\n// automatically added to the protototype of the new Class\nvar SPECIAL_KEYS = {\n  statics:            true,\n  members:            true,\n  mixins:             true,\n  extend:             true,\n  properties:         true,\n  name :              true,\n  classExtended:      true\n};\n\nvar seenDeprecations = {};\nvar deprecated = exports.deprecated = function(what, replacement) {\n  var msg = what + ' is deprecated.';\n  if (replacement) {\n    msg += '\\nUse ' + replacement + ' instead.';\n  }\n  if (!seenDeprecations[msg]) {\n    seenDeprecations[msg] = true;\n    window.console && console.warn(msg);\n  }\n};\n\n\n// This is a hold over from JX. Sometimes folks are declaring classes\n// with string values for extends. We need to track the classes that\n// have been declared by name as a result.\nvar ClassRegistry = exports.ClassRegistry = {};\n\n// Base object used in prototype chaining\nvar Base = function() {};\n\n// setup the inheritance chain from parent to child\nvar inherit = exports.inherit = function(__super__, construct) {\n  var klass;\n\n  // if we have a constructor then use it otherwise provide a constructor\n  // that automatically invokes the parent;\n  if (construct) {\n    klass = construct;\n  } else {\n    klass = function() {return __super__.apply(this, arguments);};\n  }\n\n  // setup the prototype chain without instantiating the superclass\n  Base.prototype = __super__.prototype;\n  klass.prototype = new Base();\n\n  // set the constructor property of the klass\n  klass.prototype.constructor = klass;\n\n  return klass;\n};\n\n// createClass exported and also aliased as declare\nvar createClass = exports.createClass = exports.declare = function(config) {\n  // setup the inheritance chain\n  var __super__ = config.extend;\n  var klass;\n  if (__super__) {\n    klass = inherit(__super__, config.construct);\n  } else {\n    klass = config.construct || function() {};\n  }\n\n  // set the klassName property\n  ClassRegistry[config.name] = klass;\n  klass.klassName = config.name || '';\n\n  // Add the default implementation of getDeclaredClass\n  klass.prototype.getDeclaredClass = getDeclaredClass;\n\n  // setup classExtended\n  klass.classExtended = config.classExtended ||\n    bindCommonExtend(config.extend, config.mixins, 'classExtended');\n  // setup mixinIncluded\n  klass.mixinIncluded = config.mixinIncluded ||\n    bindCommonExtend(config.extend, config.mixins, 'mixinIncluded');\n\n  // setup mixins\n  config.mixins && addMixins(klass, config.mixins);\n\n  // add the instance methods\n  addPrototypeMembers(klass, config);\n  // add the static class methods\n  config.statics && util.extend(klass, config.statics);\n\n  // custom initialization for class\n  klass.classExtended(klass, config);\n\n  // custom extension\n  config.mixins && includeMixins(klass, config.mixins);\n\n\n  // the stuff should probably be removed. Keeping it for backwards compat\n  // for now\n  doClassHierarchyTracking(klass, __super__);\n\n  return klass;\n};\n\nfunction bindCommonExtend(base, mixins, method) {\n  var extensions = [];\n  if (mixins) {\n    for (var i = mixins.length - 1; i >= 0; i--) {\n      if (mixins[i][method]) {\n        extensions.push(mixins[i][method]);\n      }\n    }\n  }\n  if (base && base[method]) {\n    extensions.push(base[method]);\n  }\n  if (extensions.length == 0) {\n    return commonExtension;\n  } else {\n    return function(klass, config) {\n      for (var i = 0; i < extensions.length; i++) {\n        extensions[i](klass, config);\n      }\n      commonExtension(klass, config);\n    };\n  }\n}\n\nfunction commonExtension(klass, config) {\n  // setup properties\n  addProperties(klass, config);\n}\n\nexports.commonExtension = commonExtension;\n\n\nfunction addPrototypeMembers(klass, config) {\n  // JX had a convention of putting instance properties/methods into a members\n  // key in the config. We are maintaining actively deprecated this\n  // functionality.\n  if (config.members) {\n    window.console && console.warn('Member is deprecated, please fix ' + config.name + '.');\n  }\n  config.members = config.members || {};\n  for (var key in config) {\n    if (!SPECIAL_KEYS[key]) {\n      config.members[key] = config[key];\n    }\n  }\n  util.extend(klass.prototype, config.members);\n}\n\nfunction includeMixins(klass, mixins) {\n  for (var i = 0; i < mixins.length; i++) {\n    klass.mixinIncluded(klass, mixins[i]);\n  }\n}\n\n// mixins are added to the prototype and optionally provide a mixinReady hook\n// Must run AFTER inheriting from parent class but before declaring current\n// class so that mixins can override parent class members but can be\n// overwritten by current class members.\nfunction addMixins(klass, mixins) {\n  var mixinReadyFunctions = [];\n  var proto = klass.prototype;\n  for (var i = 0; i < mixins.length; i++) {\n    var mixin = mixins[i];\n    for (var key in mixin) {\n      if (!proto.hasOwnProperty(key) && key !== 'mixinReady' && key !== 'properties') {\n        proto[key] = mixin[key];\n      }\n    }\n    mixin.mixinReady && mixinReadyFunctions.push(mixin.mixinReady);\n  }\n\n  if (mixinReadyFunctions.length > 0) {\n    if (proto.mixinReadyFunctions) {\n      // Make sure to maintain any existing mixinReady functions.\n      mixinReadyFunctions = proto.mixinReadyFunctions.concat(mixinReadyFunctions);\n    }\n    proto.mixinReadyFunctions = mixinReadyFunctions;\n  }\n}\n\n// Cache the auto generated setters so as to minimize\n// object creation\nvar cachedSetters = {};\nvar cachedGetters = {};\n\nfunction generateSetter(key) {\n  if (!cachedSetters[key]) {\n    var propName = PROP_PREFIX + key;\n    cachedSetters[key] = function(value) {\n      this[propName] = value;\n      return this;\n    };\n  }\n  return cachedSetters[key];\n}\n\nfunction generateGetter(key) {\n  if (!cachedGetters[key]) {\n    var propName = PROP_PREFIX + key;\n    cachedGetters[key] = function() {\n      return this[propName];\n    };\n  }\n  return cachedGetters[key];\n}\n\n// declared properties automatically create getters and setters\nfunction addProperties(klass, config) {\n  var getter, setter, proto = klass.prototype;\n  proto.get || (proto.get = getProperty);\n  proto.set || (proto.set = setProperty);\n\n  if (!config.properties) {\n    return;\n  }\n  var properties = config.properties;\n\n  var defaultValue;\n  for (var key in properties) {\n    defaultValue = properties[key];\n    setter = util.setter(key);\n    getter = util.getter(key);\n\n    if (!proto.hasOwnProperty(PROP_PREFIX + key)) {\n      proto[PROP_PREFIX + key] = defaultValue;\n    }\n    if (!proto.hasOwnProperty(setter)) {\n      proto[setter] = generateSetter(key);\n    }\n    if (!proto.hasOwnProperty(getter)) {\n      proto[getter] = generateGetter(key);\n    }\n  }\n}\n\n// shared getProperty method\nfunction getProperty(key) {\n  return this[PROP_PREFIX + key];\n}\n\n// shared setProperty method\nfunction setProperty(key, value) {\n  this[PROP_PREFIX + key] = value;\n  return this;\n}\n\nfunction doClassHierarchyTracking(klass, __super__) {\n  klass.prototype.klass = klass;\n  klass.superKlass = __super__;\n  klass.inheritanceChain = __super__ ?\n    [klass].concat(__super__.inheritanceChain) :\n    [klass];\n}\n\nfunction getDeclaredClass() {\n  return this.klass.klassName;\n}\n\n//@ sourceURL=bolt/core\n});");

// module: bolt/mixins/events
// file:   ../bolt/bolt/lib/mixins/events.js
eval("define(\"bolt/mixins/events\", function(require, exports, module) { /**\n *\n * Copyright (c) 2011-2012, Facebook, Inc.\n * All rights reserved.\n *\n * @preserve-header\n *\n */\n\n'use strict';\n\nvar arrayUtils = require('../util/array');\nvar assert = require('../util/assert').assert;\n\nvar Events = {\n\n  // ..........................................................\n  // Public\n  //\n\n  /**\n   * Add a listener for an invoked event.  While this works with the signatures\n   * - (string, Function)\n   * - (string, Function, Object)\n   * - (string, string, Object)\n   * the last is the most performant as it enables lazy binding of functions.\n   *\n   * @param event {String} The name of the event, e.g. 'updated'.\n   * @param message {String|Function} This can either be a Function to invoke, or\n   *                the name of a function on the subscriber.  It is passed whatever\n   *                arguments were passed to the invoke() function, except for the first\n   *                argument which is the event name.\n   * @param subscriber {Object} An optional parameter that specifies the context of the\n   *                callback function to be invoked.  If the second 'message' parameter\n   *                is a String, that String should refer to the name of a function on\n   *                this 'subscriber' object.  E.g. if the function is called with\n   *                ('foo', 'handleFoo', myObject), myObject should look like\n   *                {handleFoo: function() {}}\n   */\n  addListener: function(event, message, subscriber) {\n    var subscribersMap = this._subscribersMap;\n    var messagesMap = this._messagesMap;\n\n    if (__DEV__) {\n      var messageType = typeof message;\n      assert(typeof event === 'string', \"Trying to add a listener for an invalid event: \" + event);\n      assert(messageType === 'function' || messageType === 'string', \"Trying to add an invalid listener for \" + event);\n      if (messageType === 'string') {\n        assert(subscriber, \"You must provide a subscriber when adding a listener for an event\");\n      }\n    }\n\n    if (!subscribersMap) {\n      subscribersMap = this._subscribersMap = {};\n      messagesMap = this._messagesMap = {};\n    }\n\n    if (!subscribersMap[event]) {\n      subscribersMap[event] = [];\n      messagesMap[event] = [];\n    }\n\n    subscribersMap[event].push(subscriber);\n    messagesMap[event].push(message);\n\n    return this;\n  },\n\n  removeAllListeners: function(event) {\n    var subscribersMap = this._subscribersMap;\n    var messagesMap = this._messagesMap;\n\n    if (event !== undefined) {\n      if (subscribersMap) {\n        subscribersMap[event] = void 0;\n      }\n      if (messagesMap) {\n        messagesMap[event] = void 0;\n      }\n    } else {\n      this._subscribersMap = void 0;\n      this._messagesMap = void 0;\n    }\n\n    return this;\n  },\n\n  /**\n   * Remove a listener from this object.  This accepts the same parameters as\n   * addListener.\n   */\n  removeListener: function(event, message, subscriber) {\n    var eventSubscribers = this._subscribersFor(event);\n    var eventMessages = this._messagesFor(event);\n    var idx;\n    var potentialSubscriber, potentialMessage;\n\n    if (__DEV__) {\n      var messageType = typeof message;\n      assert(typeof event === 'string', \"Trying to remove a listener for an invalid event: \" + event);\n      assert(messageType === 'string' || messageType === 'function', \"Trying to remove an invalid listener for \" + event);\n      if (messageType === 'string') {\n        assert(subscriber, \"Trying to remove an event listener with an invalid subscriber\");\n      }\n    }\n\n    if (eventSubscribers) {\n      for (idx = eventSubscribers.length - 1; idx >= 0; idx -= 1) {\n        potentialSubscriber = eventSubscribers[idx];\n        potentialMessage = eventMessages[idx];\n        if (subscriber === potentialSubscriber && message === potentialMessage) {\n          arrayUtils.remove(eventSubscribers, idx);\n          arrayUtils.remove(eventMessages, idx);\n        }\n      }\n\n      if (eventSubscribers.length === 0) {\n        this._subscribersMap[event] = void 0;\n        this._messagesMap[event] = void 0;\n      }\n    }\n\n    return this;\n  },\n\n\n  // ..........................................................\n  // Protected\n  //\n\n  destroy: function() {\n    this.removeAllListeners();\n  },\n\n  // Inlining calls for reasons like http://jsperf.com/arguments-adaptor\n  // We're smoking Node's EventEmitter when using object subscription.\n  // http://jsperf.com/emit\n  // http://jsperf.com/emit-with-listeners\n  // http://jsperf.com/slice-in-emit\n  //\n  // The only limitation of this method is that if your 4th arg is undefined\n  // but you have more than 4 args, this will silently drop the remaining args.\n  // The speed improvements in avoiding .call/.apply are worth it, and who makes\n  // events with > 4 args anyway ;-)?\n  invoke: function(event, data1, data2, data3, data4) {\n    var eventSubscribers = this._subscribersFor(event);\n    if (!eventSubscribers) {\n      return;\n    }\n\n    var eventMessages = this._messagesFor(event);\n    var length, idx;\n    var subscriber, message, messageType;\n    var args, argsLength, argsIdx;\n\n    if (data4 === undefined) {\n      if (data3 === undefined) {\n        if (data2 === undefined) {\n          if (data1 === undefined) {\n            argsLength = 0;\n          } else {\n            argsLength = 1;\n          }\n        } else {\n          argsLength = 2;\n        }\n      } else {\n        argsLength = 3;\n      }\n    }\n\n    length = eventSubscribers.length;\n    for (idx = 0; idx < length; idx += 1) {\n\n      if (!this._subscribersMap) {\n        // If all listeners have been removed, break out of this loop.\n        // It means that one of the callbacks has destroyed this class,\n        // removing all listeners, and that we should not continue.\n        // This is consistent with the behavior of the browser event loop\n        break;\n      }\n\n      subscriber = eventSubscribers[idx];\n      message = eventMessages[idx];\n      messageType = typeof message;\n\n      if (messageType === 'string') {\n        switch (argsLength) {\n          case 0: subscriber[message](); break;\n          case 1: subscriber[message](data1); break;\n          case 2: subscriber[message](data1, data2); break;\n          case 3: subscriber[message](data1, data2, data3); break;\n          default:\n            if (!args) {\n              argsLength = arguments.length;\n              args = new Array(argsLength - 1);\n              for (argsIdx = 1; argsIdx < argsLength; argsIdx += 1) {\n                args[argsIdx - 1] = arguments[argsIdx];\n              }\n            }\n\n            subscriber[message].apply(subscriber, args);\n            break;\n        }\n      } else if (messageType === 'function') {\n        switch (argsLength) {\n          case 0: message.call(subscriber); break;\n          case 1: message.call(subscriber, data1); break;\n          case 2: message.call(subscriber, data1, data2); break;\n          case 3: message.call(subscriber, data1, data2, data3); break;\n          default:\n            if (!args) {\n              argsLength = arguments.length;\n              args = new Array(argsLength - 1);\n              for (argsIdx = 1; argsIdx < argsLength; argsIdx += 1) {\n                args[argsIdx - 1] = arguments[argsIdx];\n              }\n            }\n            message.apply(subscriber, args);\n            break;\n        }\n      }\n    }\n  },\n\n\n  // ..........................................................\n  // Private\n  //\n\n  _messagesMap: null,\n  _subscribersMap: null,\n\n  _messagesFor: function(event) {\n    return this._messagesMap ? this._messagesMap[event] : null;\n  },\n\n  _subscribersFor: function(event) {\n    return this._subscribersMap ? this._subscribersMap[event] : null;\n  }\n};\n\nexports.Events = Events;\n\n//@ sourceURL=bolt/mixins/events\n});");

// module: bolt/binding
// file:   ../bolt/bolt/lib/binding.js
eval("define(\"bolt/binding\", function(require, exports, module) { /**\n * Copyright (c) 2011-2012, Facebook, Inc.\n * All rights reserved.\n *\n * @option preserve-header\n *\n * The Binding class controls the connection between a Model and a View.\n *\n * When the specified property on the model is updated, the corresponding\n * property on the view is also updated.\n *\n * It is also possible to listen to events on the View, which when fired\n * retrieves the latest value from the View and updates the model.\n *\n * Usually this class is not created directly, and is instead constructed\n * by calling the setBinding function of a View.\n *\n * The Binding constructor takes the model and view as arguments as well as an\n * options object containing:\n * - modelProperty: the name of the property of the model\n * - viewProperty: the name of the property on the view\n * - property: If the name of the model and view property are equal, which\n *   is often the case, simply specify this value instead of modelProperty and\n *   viewProperty.\n * - viewEvent: the event on the View to listen to in order to update the\n *   model. Can be either a String or an array of Strings.\n * - sync: A Boolean. If false, the View is not immediately updated with\n * its corresponding model value. Otherwise it is.\n */\nvar util   = require('./util');\nvar core   = require('./core');\nvar getter = util.getter;\nvar setter = util.setter;\n\nvar Binding = exports.Binding = core.createClass({\n  name: 'Binding',\n\n  properties: {\n    // the model to bind to\n    model: null,\n\n    // the model property to bind to\n    modelProperty: 'value',\n\n    // the view to bind to\n    view: null,\n\n    // the view event to listen for\n    // note that the model event is `changed`\n    // by default we don't listen to any view event\n    viewEvent: null,\n\n    // the view property to bind to\n    viewProperty: 'value',\n\n    // shortcut for setting both view and model property when they are the same\n    property: 'value'\n  },\n\n  /**\n   * Create a new Binding to synchronize state between a view and a model\n   * @constructor\n   *\n   * @param {View} view The view to bind to\n   * @param {Model} model The model to bind\n   * @param {Object} options The options to use in binding\n   * @param {String} options.modelProperty The model property to bind to\n   * @param {String} options.viewProperty The view property to bind to\n   * @param {String} options.property A shortcut for setting both the model\n   *   and view property when they are the same\n   * @param {String} options.viewEvent the event from the view that should\n   *   trigger the binding to sync\n   *\n   * note that the model event is always `changed`\n   */\n  construct: function(view, model, options) {\n    options = options || {};\n    this.setView(view);\n    this.setModel(model);\n\n    // default the modelProperty and viewProperty to property if not specified\n    if (options.property && !options.modelProperty && !options.viewProperty) {\n      options.modelProperty = options.viewProperty = options.property;\n    }\n\n    this._modelPropertyIsFunction = util.isFunction(options.modelProperty);\n\n    // if we don't specify a viewEvent but there's a setter on the\n    // model property, set view event to 'change'.\n    // TODO:wbailey - we need to discuss if we really want this default\n    //                behavior. This is potentially pretty expensive and\n    //                I don't understand fully why the presence of a model\n    //                setter should trigger this default.\n    if (!('viewEvent' in options) &&\n      !this._modelPropertyIsFunction &&\n      util.setter(options.modelProperty) in model) {\n      options.viewEvent = 'change';\n    }\n\n    var sync = options.sync;\n    delete options.sync;\n\n    // setup the rest of the options\n    for (var name in options) {\n      if (typeof options[name] !== 'undefined') {\n        this[util.setter(name)](options[name]);\n      }\n    }\n\n    // TODO: wrap this and only include in development mode\n    // check to make sure this is a valid binding before setting up listeners\n    var validModelProperty = (this._modelPropertyGetter &&\n      this._modelPropertySetter) || this._modelPropertyIsFunction;\n    if (!this._model || !this._view || !this._viewPropertyGetter ||\n      !validModelProperty) {\n      this.destroy();\n      throw 'invalid binding: require properties not specified';\n    }\n\n    // add listeners for view events\n    var viewEvent = this.getViewEvent();\n\n    if (viewEvent) {\n      if (typeof viewEvent === 'string' || viewEvent instanceof String) {\n        viewEvent = viewEvent.split(/\\s+/);\n      }\n\n      this._viewBoundEventTypes = [];\n\n      for (var i = 0, ev, len = viewEvent.length; i < len; i++) {\n        ev = viewEvent[i];\n        if (ev) {\n          this._view.addListener(ev, 'updateModel', this);\n          this._viewBoundEventTypes.push(ev);\n        }\n      }\n    }\n\n    // add a listener for the model event\n    this._modelBound = this.getModel();\n    this._modelBound.addListener('changed', 'updateView', this);\n\n    // if the sync property is set then we should immediately synchronize\n    // the model and the view.\n    if (sync !== false) {\n      this.setViewValue(this.getModelValue());\n    }\n  },\n\n  /**\n   * store the view and cache it for internal fast lookups\n   * @param {View} view The view to bind the model to\n   */\n  setView: function(view) {\n    if (this._view) {\n      this._view.removeBinding();\n    }\n    this._view = view;\n    this.set('view', view);\n  },\n\n  /**\n   * store the model and cache it for internal fast lookups\n   * @param {Model} model The model to bind the view to\n   */\n  setModel: function(model) {\n    this.set('model', model);\n    this._model = model;\n  },\n\n  /**\n   * store the model property and cache it for internal fast lookups\n   * @param {String} proeprty the model property to bind to\n   */\n  setModelProperty: function(property) {\n    this.set('modelProperty', property);\n    // bindings allow inline functions to serve as model properties for\n    // transforming state before passing it to the view.\n    this._modelPropertyIsFunction = util.isFunction(property);\n    this._modelProperty = property;\n    if (!this._modelPropertyIsFunction) {\n      this._modelPropertyGetter = getter(property);\n      this._modelPropertySetter = setter(property);\n    }\n  },\n\n  /**\n   * store the view property and cache it for internal fast lookups\n   * @param {String} proeprty the view property to bind to\n   */\n  setViewProperty: function(property) {\n    this.set('viewProperty', property);\n    this._viewProperty = property;\n    this._viewPropertyGetter = getter(property);\n    this._viewPropertySetter = setter(property);\n  },\n\n  /**\n   * destroy the binding and clean up its observers\n   */\n  destroy: function() {\n    if (this.isDestroyed) {\n      return;\n    }\n    this.isDestroyed = true;\n\n    if (this._viewBoundEventTypes && this._view) {\n      for (var i = 0, len = this._viewBoundEventTypes.length; i < len; i++) {\n        this._view.removeListener(\n          this._viewBoundEventTypes[i],\n          'updateModel',\n          this\n        );\n      }\n      this._viewBoundEventTypes = null;\n    }\n\n    if (this._modelBound) {\n      this._modelBound.removeListener('changed', 'updateView', this);\n      this._modelBound = null;\n    }\n\n    this.setModel(null);\n    this.setView(null);\n    this.setModelProperty(null);\n    this.setViewProperty(null);\n  },\n\n  /**\n   * get the bound view value\n   */\n  getViewValue: function() {\n    return this._view[this._viewPropertyGetter]();\n  },\n\n  /**\n   * set the bound view value\n   * @param value\n   */\n  setViewValue: function(value) {\n    this._view[this._viewPropertySetter](value);\n    return this;\n  },\n\n  /**\n   * get the model value\n   */\n  getModelValue: function() {\n    if (this._modelPropertyIsFunction) {\n      // TODO: Replace context with the owner\n      return this._modelProperty.call(null, this._model);\n    }\n    return this._model.getSafe(this._modelProperty);\n  },\n\n  /**\n   * set the model value\n   * @param value\n   */\n  setModelValue: function(value) {\n    // inline model properties don't have setters yet\n    if (!this._modelPropertyIsFunction) {\n      this._model.setSafe(this._modelProperty, value);\n    }\n    return this;\n  },\n\n  /**\n   * update the model state due to a change in view state\n   * @param {Event} event the view event triggered by the state change\n   */\n  updateModel: function(event) {\n    if (this.isDestroyed) {\n      throw 'destroyed binding invoked';\n    }\n    // TODO: wbailey seems like we might want to be more strict about\n    //       the api here. Right now bindings can silently fail due to a getter\n    //       or setter not being implemented. I propose that we be explict and\n    //       require a `one way` or `two way` property for each binding. Then\n    //       if the appropriate getter/setter is not found we should throw.\n    if (this._view[this._viewPropertyGetter]) {\n      var viewValue = this.getViewValue();\n      if (!util.isEqual(viewValue, this.getModelValue())) {\n        this.setModelValue(viewValue);\n      }\n    }\n  },\n\n  /**\n   * Update the view when a model state change is triggered\n   * @param {Event} event the model event triggered by the state change\n   */\n  updateView: function(data) {\n    var changedProperties = data.changedProperties;\n\n    if (this.isDestroyed) {\n      throw 'destroyed binding invoked';\n    }\n    if (changedProperties) {\n      // this change is relevant if it directly changes the modelProperty that\n      // we are bound to, or a derived property (which cannot be a base\n      // property, and will always be evaluated on every model change)\n\n      // TODO:wbailey we should try annotating our derived properties with the\n      //              base properties they depend on so we can trigger bindings\n      //              more selectively. Checkout how sproutcore does this.\n      if (this._modelPropertyIsFunction ||\n        changedProperties.hasOwnProperty(this._modelProperty) ||\n        !this._model.isBaseProperty(this._modelProperty)) {\n\n        var modelValue = this.getModelValue();\n        if (this._view[this._viewPropertyGetter]) {\n          if (!util.isEqual(this.getViewValue(), modelValue)) {\n            this.setViewValue(modelValue);\n          }\n        } else {\n          this.setViewValue(modelValue);\n        }\n      }\n    }\n  }\n\n});\n\n//@ sourceURL=bolt/binding\n});");

// module: bolt/view
// file:   ../bolt/bolt/lib/view.js
eval("define(\"bolt/view\", function(require, exports, module) { /**\n * Copyright (c) 2011-2012, Facebook, Inc.\n * All rights reserved.\n *\n * @option preserve-header\n *\n */\n\n'use strict';\n\nvar util     = require('./util');\nvar core     = require('./core');\nvar dom      = require('./dom');\n\nvar Responder = require('./mixins/responder').Responder;\nvar Container = require('./mixins/container').Container;\nvar Events = require('./mixins/events').Events;\nvar CustomViewEvents = require('./mixins/custom_view_events').CustomViewEvents;\n\nfunction setOwner(viewSpec) {\n  viewSpec.owner = viewSpec.owner || this;\n}\n\nvar View = exports.View = core.createClass({\n\n  name: 'View',\n\n  mixins: [Responder, CustomViewEvents, Container, Events],\n\n  // Override declare in your subclasses to provide default options for your\n  // specific View. This actually removes the need for a custom render\n  // function, since childViews are just another part of setup. Views that\n  // render in the old way will still work for backwards compatibility.\n  //\n  //   declaring a custom view can now be as simple as this:\n  //   createClass({\n  //     name: 'CustomView',\n  //     extend: View,\n  //     declare: {\n  //       color: 'red'\n  //       childViews: [\n  //         {content: 'foo'}\n  //       ]\n  //     }\n  //   }\n  //\n  // NOTE: wbailey 5-10-2011\n  // The way we are do setLayout inside of render obscures what is\n  // actually happening. The setChildViews setter at each level of the\n  // hierarchy actually does the recursion. Thus a cleaner api is to just let\n  // this happen during setup and provide a way to *declare* overridable default\n  // options.\n  declare: function() {},\n\n  construct: function(options) {\n    this._childViews = [];\n\n    // the options for the view are now derived by extending a shallow copy\n    // of the the *declared* options on the prototype. This allows you to\n    // specify any property of the parent in the declare block and optionally\n    // override it with options passed to the constructor.\n    var declOptions = this.declare(options);\n\n    // voloko: extremly hacky, and supports only childViews property. So\n    // leftChildViews and rightChildViews will not work.\n    // Set the owner of each of the childViews to default to this View\n    if (declOptions && declOptions.childViews) {\n      util.forEach(\n        declOptions.childViews,\n        setOwner,\n        this);\n    }\n    var declClassName = declOptions && declOptions.className;\n\n    // if both declOptions and options given => extend, otherwise use available\n    var optionsToUse =\n      declOptions && options ? util.extend(declOptions, options || {}) :\n      declOptions || options || {};\n\n    if (declClassName && optionsToUse.className !== declClassName) {\n      optionsToUse.className = declClassName + ' ' + optionsToUse.className;\n    }\n\n    // should probably remove this guys to save some memory\n    this.refs = {};\n\n    this.createDom(optionsToUse);\n\n    if (this.render) {\n      require('./core').deprecated('View.render', 'View.setup');\n      this.render(optionsToUse);\n    }\n\n    var i, l;\n\n    // if we haven't yet captured the cssClass for this view class use the\n    // inheritance chain to create a list of css classes generated from the\n    // js class name and cache it on the js class for future use.\n    var klass = this.klass;\n    if (!klass.cssClass) {\n      var inheritanceChain = klass.inheritanceChain, classes = [];\n      l = inheritanceChain.length;\n      var klassName;\n      for (i = 0; i < l; i += 1) {\n        klassName = inheritanceChain[i].klassName;\n        if (klassName) {\n          classes.unshift('bt-' + util.hyphenate(klassName));\n        }\n      }\n      klass.cssClass = classes.join(' ');\n    }\n\n    this.setup(optionsToUse);\n\n    // the initial css class for a view should be its inherited class followed\n    // by any passed in className or additionalClasses properties.\n    // e.g. bt-view custom-class-foo\n    var existingClass, classToSet, inheritedClass;\n    existingClass = this.getClassName();\n    classToSet = inheritedClass = klass.cssClass;\n\n    if (existingClass) {\n      classToSet = inheritedClass + ' ' + existingClass;\n    }\n    this.setClassName(classToSet);\n\n    // call any mixinReady functions\n    if (this.mixinReadyFunctions) {\n      l = this.mixinReadyFunctions.length;\n      for (i = 0; i < l; i += 1) {\n        this.mixinReadyFunctions[i].call(this);\n      }\n    }\n\n    // hook to setup any post construct handlers\n    if (this.ready) {\n      this.ready();\n    }\n  },\n\n  properties: {\n    metadata: null\n  },\n\n  // Set up the delegated properties. A property that is just a string sets up\n  // a setter and getter with that name on the parent widget, e.g. the property\n  // of 'label' delegated to 'node' will set up a setLabel and getLabel function\n  // that looks for either this.node or a referenced child widget in\n  // this.refs['node'], then sets and gets the label on it.  A property that is\n  // a JSON object, with both an 'alias' and 'name' member works slightly\n  // differently.  A getter and setter for the alias are added to the parent\n  // widget, but these functions look for the 'name' in the child property.\n  // E.g. a property {alias: 'label', name: 'value '} delegated to 'node'\n  // would create the functions 'getLabel' and 'setLabel' on the parent view,\n  // but would get and set the 'value' property of 'node'.\n  // By default, anything extending the View class will have these properties\n  // delegated to the node returned from getNode().\n  delegateProperties: {\n    node: [\n      'data-ref',\n      'disabled',\n      'id',\n      'name',\n      'tabIndex'\n      /* We won't delegate tagName because it will be slow and redundant to set\n       * it, if the creator doesn't know it's kind after creating it, then\n       * they're not very organized.\n       * We won't delegate innerHtml because you should create and remove\n       * children in a way that doesn't leak memory removeChildViews().\n       */\n    ],\n    style: [\n      'height',\n      'width'\n    ]\n  },\n\n  getNextResponder: function() {\n    return this.get('nextResponder') || this.getParentView();\n  },\n\n  /*\n   * set the data attribute on the DOM node\n   */\n  setMetadata: function(obj) {\n    this.set('metadata', obj);\n    var node = this.getNode();\n    var name;\n\n    for (name in obj) {\n      if (obj.hasOwnProperty(name)) {\n        node.setAttribute('data-' + name, obj[name]);\n      }\n    }\n  },\n\n  /**\n   * create the dom node for this view to render within\n   * options\n   *   - tagName: specify a tag name to use when creating the dom node\n   *              other than the default div\n   */\n  createDom: function(options) {\n    var node = this.getNode();\n    if (!node) {\n      this.setNode(dom.createElement(options.tagName || 'div'));\n      node = this.getNode();\n    }\n    return node;\n  },\n\n  /**\n   * find the nearest ref for a given node\n   * this is useful for event handling\n   */\n  findContainingRef: function(node) {\n    while (node !== this.getNode()) {\n      var ref = node.getAttribute('data-ref');\n      if (ref && this.refs && this.refs[ref]) {\n        return this.refs[ref];\n      }\n      node = node.parentNode;\n    }\n    return false;\n  },\n\n  /**\n   * add additional classes to the node for this view\n   */\n  setAdditionalClasses: function(classes) {\n    if (util.isArray(classes)) { classes = classes.join(' '); }\n    return this.addClass(classes);\n  },\n\n  __sendEvent: Responder.sendEvent,\n\n  sendEvent: function(event) {\n\n    var happened = false;\n    var eventType = event.type;\n\n    if (event.isBoltEvent) {\n      var handlerName, refView;\n      var ref;\n      for (var i = 0, len = event.refCount; i < len; i++) {\n        ref = event.refs[i];\n        handlerName = 'on'\n          + ref.charAt(0).toUpperCase() + ref.substr(1)\n          + eventType.charAt(0).toUpperCase() + eventType.substr(1);\n        refView = this.findRef(ref);\n\n        // three conditions to bail:\n        // (1) the view handling the event doesn't have a ref by the correct name\n        // (2) the view has the ref, but doesn't have the handler by the correct name\n        // (3) the target view, although named with the same ref, isn't actually the right view\n        if (this[handlerName] && refView) {\n          this[handlerName](event);\n          happened = true;\n        }\n      }\n    }\n\n\n    // Support listening to DOM events\n    if (this._domListeners && this._domListeners[eventType]) {\n      var stopPropagation = event.stopPropagation;\n      var preventDefault = event.preventDefault;\n\n      // Prevent the invoked function from calling stopPropagation or preventDefault\n      // as this is really a custom event that they are receiving, and should not be\n      // able to effect the UI behavior.\n      event.stopPropagation = event.preventDefault = null;\n\n      try {\n        this.invoke(eventType, event);\n\n      } catch(e) {\n        // Ridiculous, but IE doesn't support a finally block without\n        // a catch block. Sigh.\n        throw e;\n      } finally {\n        // Even if a listener throws an error, clean up\n        event.stopPropagation = stopPropagation;\n        event.preventDefault = preventDefault;\n      }\n    }\n    return this.__sendEvent(event) || happened;\n  },\n\n  __addListener: Events.addListener,\n\n  /**\n   * Add either a DOM or custom event listener.  Note that if adding a DOM\n   * event listener, it is not possible to call stopPropagation() or\n   * preventDefault() on the event object.\n   *\n   * See Events.addListener for comprehensive documentation\n   */\n  addListener: function(event, message, subscriber) {\n\n    // If the event dispatcher handles the event, set up a shim function\n    // to also do an invoke() call with the same event\n    if (this.getEventDispatcher().isDomEvent(event)) {\n      this._domListeners = this._domListeners || {};\n      this._domListeners[event] = true;\n    }\n\n    // Call the original addListener function from the Events mixin\n    return this.__addListener(event, message, subscriber);\n  },\n\n  __containerDestroy: Container.destroy,\n\n  __eventsDestroy: Events.destroy,\n\n  destroy: function() {\n\n    // Ensure that destroy() for both Events and Container is called, as the mixin\n    // system makes one override the other, and this is preferable\n    // to making one depend on the other\n    this.__eventsDestroy();\n    this.__containerDestroy();\n  }\n});\n\n\n//@ sourceURL=bolt/view\n});");

// module: bolt/dom/index
// file:   ../bolt/bolt/lib/dom/index.js
eval("define(\"bolt/dom/index\", function(require, exports, module) { /**\n * Copyright (c) 2011-2012, Facebook, Inc.\n * All rights reserved.\n *\n * @option preserve-header\n *\n */\n\n/*globals module */\n\n'use strict';\n\nvar util = require('../util');\nvar guidFor = require('../util/guid').guidFor;\nvar arrayUtils = require('../util/array');\n\nvar oneOrMoreSpacesRegex = /\\s+/;\nvar removeRegex1 = /^\\s\\s*/;\nvar removeRegex2 = /\\s\\s*$/;\n\n// Global data cache, keyed on the guid for an element\n// This is used to store data added using data(), kept in memory so it doesn't\n// get set on elements where it has a chance of leaking (especially in IE).\nvar dataCache = {};\n\n// Some DOM events are not standarized yet (the ones below). They are exposed\n// via a set of prefixed events based on the vendor of the current browser.\n// When an event is added with one of the following names, we do the rewrite\n// Insofar as the listeners are concerned, the only way they can tell if the\n// rewrite actually occurred is checking the originalEvent.type property\nvar prefixedEvent = require('./feature_detect').prefixedEvent;\nvar OVERRIDDEN_EVENT_TYPES = {\n  'animationend': prefixedEvent('animation', 'animationEnd'),\n  'animationiteration': prefixedEvent('animation', 'animationIteration'),\n  'animationstart': prefixedEvent('animation', 'animationStart'),\n  'transitionend': prefixedEvent('transition', 'transitionEnd')\n};\n\nvar OVERRIDDEN_EVENT_TYPES_REVERSE = {};\nvar overridenEventType;\nfor (overridenEventType in OVERRIDDEN_EVENT_TYPES) {\n  if (OVERRIDDEN_EVENT_TYPES.hasOwnProperty(overridenEventType)) {\n    OVERRIDDEN_EVENT_TYPES_REVERSE[OVERRIDDEN_EVENT_TYPES[overridenEventType]] = overridenEventType;\n  }\n}\n\nvar eventModule = require('./event');\nvar EventShim = eventModule.EventShim;\nvar resetEvent = eventModule.resetEvent;\n\nvar eventShim;\n\nfunction dispatchEvent(element, event) {\n\n  var events = dom.getData(element, '_events');\n  var handlers = events && events[event.type];\n  var length, idx;\n\n  if (!handlers) {\n    return;\n  }\n\n  if (!eventShim) {\n    eventShim = new EventShim();\n  }\n  resetEvent(eventShim, event);\n\n  if (OVERRIDDEN_EVENT_TYPES_REVERSE[event.type]) {\n    eventShim.type = OVERRIDDEN_EVENT_TYPES_REVERSE[event.type];\n  }\n\n  length = handlers.length;\n  for (idx = 0; idx < length; idx += 1) {\n    handlers[idx].call(element, eventShim);\n  }\n\n  // IE doesn't support Event.preventDefault, instead you have to return\n  // false to prevent the default action, or any other value to allow it to continue\n  return !eventShim.defaultPrevented;\n}\n\n/**\n * Dom convinience methods\n */\nvar dom = module.exports = {\n\n  /**\n   * Registers a handler for an event that happens on the passed element\n   *\n   * @param {Element} element\n   * @param {String} type\n   * @param {Function} handler\n   */\n  addListener: function(element, type, handler) {\n    var events = this.getData(element, '_events');\n    var handlers, eventListener;\n\n    // map a generic event into a browser-prefixed event\n    if (OVERRIDDEN_EVENT_TYPES[type]) {\n      type = OVERRIDDEN_EVENT_TYPES[type];\n    }\n\n    if (!events) {\n      events = {};\n      this.setData(element, '_events', events);\n    }\n\n    // only generate one handler per element\n    // we need to do this because IE is messed up in how it handles the event\n    // targetting\n    eventListener = events._listener;\n    if (!eventListener) {\n      eventListener =  events._listener = function(event) {\n        // Support IE by getting window.event if the event object is not passed\n        // to the listener. Sigh.\n        return dispatchEvent(eventListener.element, event || window.event);\n      };\n      eventListener.element = element;\n    }\n\n    handlers = events[type];\n    if (!handlers) {\n      handlers = events[type] = [];\n      if (element.addEventListener) {\n        element.addEventListener(type, eventListener);\n      } else if (element.attachEvent) {\n        element.attachEvent('on' + type, eventListener);\n      }\n    }\n\n    handlers.push(handler);\n  },\n\n  /**\n   * Removes a registered handler for an event\n   *\n   * @param {Element} element\n   * @param {String} type\n   * @param {Function} handler\n   */\n  removeListener: function(element, type, handler) {\n    var events = this.getData(element, '_events');\n    var handlers, handlerGuid;\n    var length, idx, potentialHandler;\n\n    // map a generic event into a browser-prefixed event\n    if (OVERRIDDEN_EVENT_TYPES[type]) {\n      type = OVERRIDDEN_EVENT_TYPES[type];\n    }\n\n    if (!events || !events[type]) {\n      return;\n    }\n\n    handlerGuid = guidFor(handler);\n    handlers = events[type];\n    length = handlers.length;\n    for (idx = 0; idx < length; idx += 1) {\n      potentialHandler = handlers[idx];\n      if (guidFor(potentialHandler) === handlerGuid) {\n        arrayUtils.remove(handlers, idx);\n      }\n    }\n\n    if (handlers.length === 0) {\n      if (element.removeEventListener) {\n        element.removeEventListener(type, events._listener);\n      } else if (element.detachEvent) {\n        element.detachEvent('on' + type, events._listener);\n      }\n      delete events[type];\n    }\n  },\n\n  /**\n   * Convenience wrapper around document.createElement\n   * Creates dom element with given tagName, options and children\n   *\n   * @param {string} tagName\n   * @param {object} options\n   * @param {array} children\n   * @returns {Element} created element\n   */\n  createElement: function(tagName, options, children) {\n    var e = document.createElement(tagName);\n\n    if (options) {\n      var value;\n      for (var name in options) {\n        if (options[name] !== undefined) {\n          value = options[name];\n\n          if (name === 'innerHTML') {\n            dom.dangerouslyInjectHtml(e, value);\n          } else if(name === 'content') {\n            dom.replaceText(e, value);\n          } else if (name === 'style') {\n            e.style.cssText = value;\n          } else if (name === 'selected') {\n            e.setAttribute('selected', 'selected');\n          } else {\n            e[name] = value;\n          }\n        }\n      }\n    }\n    if (children !== undefined) {\n      dom.appendContent(e, children);\n    }\n    return e;\n  },\n\n  /**\n   * Sets data on an element, which can be retrieved using getData\n   *\n   * @param {Element} element\n   * @param {String} key\n   * @param {Object} value\n   * @returns {Object} the value\n   */\n  setData: function(element, key, value) {\n    var id = guidFor(element);\n    var elemData = dataCache[id];\n\n    if (!elemData) {\n      elemData = dataCache[id] = {};\n    }\n\n    if (key === undefined) {\n      return elemData;\n    }\n\n    if (value !== undefined) {\n      elemData[key] = value;\n    }\n\n    return elemData[key];\n  },\n\n  /**\n   * Gets data off an element. If you do not pass a key, you get the data object\n   * for the element\n   *\n   * @param {Element} element\n   * @param {String} [key]\n   * @returns {Object} the key's value, or the element's data\n   */\n  getData: function(element, key) {\n    var id = guidFor(element);\n    var elemData = dataCache[id];\n\n    if (!elemData) {\n      elemData = dataCache[id] = {};\n    }\n\n    return elemData && elemData[key];\n  },\n\n  removeElement: function(element) {\n    if (element && element.parentNode) {\n      element.parentNode.removeChild(element);\n    }\n  },\n\n  /**\n   * Convert an html-string into a DOM node; this is an unsafe operation.\n   *\n   * @param {htmlstring}\n   * @returns {Node or DocumentFragment}\n   */\n  fromHTML: function(html) {\n    if (__DEV__) {\n      window.console && console.warn('Converting a raw HTML string: '+html);\n    }\n    var div = document.createElement('div');\n    div.innerHTML = html;\n    if (div.firstChild && !div.firstChild.nextSibling) {\n      return div.firstChild;\n    } else {\n      var frag = document.createDocumentFragment();\n      while (div.firstChild) {\n        frag.appendChild(div.firstChild);\n      }\n      return frag;\n    }\n  },\n\n  hasClass: function(elem, className) {\n    return (' ' + elem.className + ' ').indexOf(' ' + className + ' ') > -1;\n  },\n\n  /**\n   * Add one or more CSS classes to a DOM node\n   * @param elem {DomNode} The element on which to change the className\n   * @param classNames {String} One or more CSS classes, separated by spaces\n   */\n  addClass: function(elem, classNames) {\n    var string = elem.className;\n    var original = string;\n\n    // Optimize for adding a single class, which is common\n    if (classNames.indexOf(' ') > -1) {\n      var names = classNames.split(oneOrMoreSpacesRegex);\n      var length = names.length;\n      for (var i = 0; i < length; i += 1) {\n        if (!dom.hasClass(elem, names[i])) {\n          string += (string ? ' ' : '') + names[i];\n        }\n      }\n    } else {\n      if (!dom.hasClass(elem, classNames)) {\n        string += (string ? ' ' : '') + classNames;\n      }\n    }\n\n    // Do not change the DOM element unless the class has actually changed\n    if (string !== original) {\n      elem.className = string;\n    }\n  },\n\n  /**\n   * Remove one or more CSS classes to a DOM node\n   * @param elem {DomNode} The element on which to change the className\n   * @param classNames {String} One or more CSS classes, separated by spaces\n   */\n  removeClass: function(elem, classNames) {\n    var empty = ' ';\n    var original = elem.className;\n    var string = empty + original + empty;\n\n    // Optimize for removing a single class, which is common\n    if (classNames.indexOf(' ') > -1) {\n      var names = classNames.split(oneOrMoreSpacesRegex);\n      var length = names.length;\n      for (var i = 0; i < length; i += 1) {\n        string = string.replace(empty + names[i] + empty, empty);\n      }\n    } else {\n      // Just change the string once, don't create an Array\n      string = string.replace(empty + classNames + empty, empty);\n    }\n\n    string = string.replace(removeRegex1, '').replace(removeRegex2, '');\n\n    // Do not change the DOM element unless the class has actually changed\n    if (string !== original) {\n      elem.className = string;\n    }\n  },\n\n  /**\n   * Adds or removes one or more class names.\n   *\n   * @param elem {DomNode} The elemen on which to change the className\n   * @param className {String} A single CSS class to add or remove\n   * @param condition {Boolean} If true, the CSS class is added.  If false\n   *                    the CSS class is removed.  If not specified, the\n   *                    CSS class is added or removed depending on whether\n   *                    or not it already exists on the node.\n   */\n  toggleClass: function(elem, className, condition) {\n    if (arguments.length < 3) {\n      condition = !dom.hasClass(elem, className);\n    }\n    if (condition) {\n      dom.addClass(elem, className);\n    } else {\n      dom.removeClass(elem, className);\n    }\n  },\n\n  alterClass: function(elem, className, condition) {\n    require('../core').deprecated('alterClass', 'toggleClass');\n    return this.toggleClass.apply(this, arguments);\n  },\n\n  /**\n   * Converts a text string into an HTML representation of that text\n   * by escaping HTML metacharacters. This is normally only necessary\n   * if you intend to call dangerouslyInjectHtml with the result,\n   * which should generally be avoided.\n   *\n   * @param {string} text\n   * @returns {string} html-string\n   */\n  escapeHTML: function(html) {\n    return (html + '')\n      .replace(/&/g,'&amp;')\n      .replace(/</g,'&lt;')\n      .replace(/>/g,'&gt;')\n      .replace(/\\\"/g,'&quot;')\n      .replace(/\\'/g,'&#x27;');\n  },\n\n  htmlize: function(html) {\n    require('../core').deprecated('htmlize', 'escapeHTML');\n    return this.escapeHTML(html);\n  },\n\n  identify: guidFor,\n\n  clear: function(node) {\n    node.innerHTML = '';\n  },\n\n  /**\n   * This function is equivalent to eval(), with a slightly different\n   * input encoding. Passing around raw HTML strings is the easiest\n   * way to accidentally introduce XSS holes. When it cannot be\n   * avoided, e.g. when you receive a trusted HTML string from outside\n   * your program, the easiest way to limit the amount of code that\n   * can potentially introduce an XSS hole is to exchange the string\n   * for an actual DOM nodes as soon as possible (see DOM.fromHTML).\n   */\n  dangerouslyInjectHtml: function(node, html) {\n    if (__DEV__) {\n      var logHtml = html;\n      if (logHtml.length > 50) {\n        logHtml = logHtml.substr(0, 50)+'...';\n      }\n      window.console && console.warn('Injecting a raw HTML string: '+logHtml);\n    }\n    node.innerHTML = html;\n  },\n\n  /**\n   * Replace all the content of the DOM node with a text string.\n   */\n  replaceText: function(node, text) {\n    this.replaceContent(node, text + '');\n  },\n\n  /**\n   * Replace all the content of the DOM node with a list of dom nodes\n   * and strings. This accepts nested lists so that any function that\n   * wants to \"append\" markup can just put it in an array.\n   */\n  replaceContent: function(node, content) {\n    while (node.firstChild) {\n      node.removeChild(node.firstChild);\n    }\n    dom.appendContent(node, content);\n  },\n\n  appendContent: function(node, data) {\n    var length, idx;\n\n    if (data instanceof Array) {\n      length = data.length;\n      for (idx = 0; idx < length; idx += 1) {\n        dom.appendContent(node, data[idx]);\n      }\n    } else if (data !== null && data !== undefined) {\n      if (!data.nodeType) {\n        data = document.createTextNode(data + '');\n      }\n      node.appendChild(data);\n    }\n  },\n\n  /**\n   * get the bounding rect for the view\n   */\n  getRect: function(node) {\n    var rect = node.getBoundingClientRect();\n    rect = {\n      // FF doesn't round the top/bottom coordinates.\n      top:    Math.round(rect.top),\n      bottom: Math.round(rect.bottom),\n      left: rect.left,\n      right: rect.right\n    };\n    // IE 8 doesn't give you width nor height\n    rect.width = rect.right - rect.left;\n    rect.height = rect.bottom - rect.top;\n    return rect;\n  },\n\n  getScrollAdjustedRect: function(node) {\n    var rect = dom.getRect(node);\n\n    var body = document.body,\n        docElem = document.documentElement,\n        scrollTop = window.pageYOffset || body.scrollTop ||\n          (docElem && docElem.scrollTop) || 0,\n        scrollLeft = window.pageXOffset || body.scrollLeft ||\n          (docElem && docElem.scrollLeft) || 0;\n\n    rect.top += scrollTop;\n    rect.bottom += scrollTop;\n    rect.left += scrollLeft;\n    rect.right += scrollLeft;\n\n    return rect;\n  }\n};\n\n//@ sourceURL=bolt/dom\n});");

// module: bolt/mixins/container
// file:   ../bolt/bolt/lib/mixins/container.js
eval("define(\"bolt/mixins/container\", function(require, exports, module) { /**\n *\n * Copyright (c) 2011-2012, Facebook, Inc.\n * All rights reserved.\n *\n * @preserve-header\n *\n */\n\n'use strict';\n\nvar util    = require('../util');\nvar core    = require('../core');\nvar dom     = require('../dom');\nvar builder = require('../builder');\n\nvar Binding = require('../binding').Binding;\n\nvar CanDelegateProperties =\n  require('./can_delegate_properties').CanDelegateProperties;\n\nvar defaultEventDispatcher = require('../event_dispatcher').getInstance();\n\n/* This options are special. They are handled during or event before setup\n * There's no way to define normal options with the given names */\nvar SETUP_OPTIONS = {\n  owner: true,\n  childViews: true,\n  view: true,\n  tagName: true\n};\n\nvar ContainerRegistry = {};\n\nvar emptyArr = [];\nvar emptyStr = '';\n\n/**\n * Mixin for dom-node-rooted containers.\n * A Container is a dom-node-rooted object that provides the functionality:\n *  1. Ability to contain other Containers.\n *  2. May be contained within another Container.\n *  3. Partially participates in reference tracking - to the extent that it\n *     may *be a reference* of it's owner.\n *\n * The requirements for using this mixin are:\n *  1. The class who mixes this in must provide the container's node when\n *      requested with this.getNode(). The mixer may allocate the node in any\n *      way they wish, but it mustn't be appended to the dom yet. The BoltJs\n *      system will handle placing the container into the heirarchy and\n *      eventually placing the entire tree into the dom.\n *  2. Before invoking the constructor from this mixin, the ability to provide\n *     this.getNode() must be implemented - the node needs to be allocated and\n *     available before invoking this mixin's 'construct' function.\n *\n * Does *not* provide functionality for:\n *  1. Keeping track of it's own references. There should never be references\n *    to this.refs. This mixin might be used in mixers who do not track their\n *    references (TagView etc.)\n *  2. Delegating any properties to it's node. (This might not be true - but\n *    we should try to make it true.)\n *\n * Any class that mixes in Container also receive seters and getters on some\n * very commonly used attributes that are relevant to any view that is a\n * container.\n *\n * @jwalke todo: consider removing ownership tracking (at least from this\n *                mixin. It can consume a lot of time for mixers who don't\n *                need to establish ownership).\n *\n */\n\nvar findClosest = exports.findClosest = function(node) {\n  while (node) {\n    var id = dom.identify(node);\n    if (ContainerRegistry[id]) {\n      return ContainerRegistry[id];\n    }\n    node = node.parentNode;\n  }\n  return null;\n};\n\nvar Container = exports.Container = util.extend({\n\n  properties: {\n    model: null,\n    persistentDisplay: null,\n    eventManager: null,\n\n    // this is also defined in Responder, and classes that mix both\n    // Container and Responder will 'overwrite' the property, but this\n    // is ok, since both point to the same default value\n    eventDispatcher: defaultEventDispatcher\n  },\n\n  delegateProperties: {\n    node: [\n      /* @jwalke let's not delegate tagName, it's just extra CPU to set,\n       * is redundant, and if you want to get the tagName, you should know it\n       * because you set it!        // this'tagName', */\n      'scrollTop',\n      'scrollLeft',\n      'scrollHeight',\n      'scrollWidth',\n      { name: 'innerHTML', alias: 'content'},\n      { name: 'innerHTML', alias: 'dangerouslyInjectedHtml' }\n    ]\n  },\n\n  /* private properties with getters and setters that have default values */\n  _node: null,\n  _owner: null,\n  _parentView: null,\n  _inDocument: false,\n\n  setContent: function(content) {\n    this.clearChildren();\n    dom.replaceContent(this.getNode(), content);\n  },\n\n  /**\n   * This function is equivalent to eval(), with a slightly different\n   * input encoding. Passing around raw HTML strings is the easiest\n   * way to accidentally introduce XSS holes. When it cannot be\n   * avoided, e.g. when you receive a trusted HTML string from outside\n   * your program, the easiest way to limit the amount of code that\n   * can potentially introduce an XSS hole is to exchange the string\n   * for an actual DOM nodes as soon as possible (see DOM.fromHTML).\n   */\n  setDangerouslyInjectedHtml: function(dangerouslyInjectedHtml) {\n    this.clearChildren();\n    dom.dangerouslyInjectHtml(this.getNode(), dangerouslyInjectedHtml);\n  },\n\n  setEventDispatcher: function(value) {\n    this.set('eventDispatcher', value);\n    util.forEach(this._childViews, this._setEventDispatcherOnChild, this);\n  },\n\n  _setEventDispatcherOnChild: function(child) {\n    child.setEventDispatcher(this.getEventDispatcher());\n  },\n\n  /*\n   * The following functions are called often during view construction, so we\n   * optimize them.\n   */\n  getNode: function() {\n    return this._node;\n  },\n  setNode: function(node) {\n    this._node = node;\n    return this;\n  },\n\n  getClassName: function() {\n    return this._node.className;\n  },\n  setClassName: function(className) {\n    this._node.className = className;\n    return this;\n  },\n\n  /**\n   * This sets up the child views, establishing ownership, and sets the options.\n   *\n   * Before: this.getNode() must return the container node.\n   */\n  setup: function(options) {\n    if (!this._childViews) {\n      this._childViews = [];\n    }\n\n    // owner is used in various places during the setup process so we\n    // guarantee that it is always set before any other options.\n    if ('owner' in options) {\n      this._owner = options.owner;\n    }\n\n    // childViews is always handled first. This means that we setup the\n    // hierarchy recursively depth first. This is important because it\n    // allows the full hierarchy of refs to be defined before any potential\n    // delegate properties are setup which might need to reference a child.\n    if ('childViews' in options) {\n      this.setChildViews(options.childViews);\n    }\n\n    this.setupOptions(options);\n\n    /* register a reference on the dom node, so we can find the view later\n     * from it. To prevent possible memory leaks in some of the browsers\n     * register through an id instead of an attribute on a node */\n    ContainerRegistry[dom.identify(this._node)] = this;\n\n    dom.setData(this._node, 'view', this);\n  },\n\n\n  /**\n   * Mixers may override this to do something more optimial.\n   */\n  setupOptions: function(options) {\n    /*\n     * This likely doesn't belong in the 'Container' mixin. Containers only\n     * provide functionality for managing a set of children under a dom node\n     * root.\n     */\n    for (var key in options) {\n      if (!SETUP_OPTIONS[key]) {\n        this._setupOption(key, options[key]);\n      }\n    }\n  },\n\n\n  /**\n   * #todoverysoon: This probably doesn't belong in this base class and we\n   * should not automatically set things on the node by default when we can't\n   * find a setter.\n   */\n  _setupOption: function(key, value) {\n    var setter = util.setter(key);\n\n    if (this[setter]) {\n      // if we have a setter, just set\n      this[setter](value);\n    } else if (key.indexOf('on') === 0) {\n      window.console && console.warn(\"You can no longer add event listeners in declare(). Use ref handlers (see documentation) instead. If this is a false alarm, just ignore it and we'll remove this error soon\");\n    } else {\n      // as a last resort set the value on the node directly\n      if (typeof(value) !== 'function' && typeof(value) !== 'object') {\n        this._node.setAttribute(key, value + emptyStr);\n      }\n    }\n  },\n\n  getOwner: function() {\n    var owner = this._owner;\n    if (!owner) {\n      var parentView = this._parentView;\n      owner = (parentView && parentView.getOwner()) || this;\n      this._owner = owner;\n    }\n    return owner;\n  },\n\n  setOwner: function(owner) {\n    this._owner = owner;\n    return this;\n  },\n\n\n  /**\n   * DATA BINDING\n   */\n\n  /**\n   * TODO:wbailey revisit this\n   */\n  setBinding: function(options) {\n    // NB:wbailey deprecating the 3 arguments signature in favor of passing\n    // a single object argument that contains the three required keys.\n    var model, bindingOptions, defaultBindingOptions;\n    if (arguments.length === 1 && typeof options === 'object') {\n      model = options.model;\n      bindingOptions = options.options;\n      defaultBindingOptions = options.defaultOptions;\n    } else {\n      model = arguments[0];\n      bindingOptions = arguments[1];\n      defaultBindingOptions = arguments[2];\n    }\n    this.set('model', model);\n    this.removeBinding();\n    this._binding = [];\n\n    // Create multiple binding objects, one per property binding.\n    // This creates a listener per binding.  It optimizes for the use\n    // case where a widget will almost always have just one binding.\n    // The alternative is to create a single binding that listens to\n    // a single 'onChange' method on a view, then does a map lookup\n    // for each view-to-model binding and executes it.  At runtime\n    // this will be much less performant, hence this approach.\n    var opt;\n    if (!util.isArray(bindingOptions)) {\n      bindingOptions = [bindingOptions];\n    }\n    for (var i = 0; i < bindingOptions.length; i += 1) {\n      opt = util.extend({}, bindingOptions[i]);\n      if (defaultBindingOptions) {\n        for (var name in defaultBindingOptions) {\n          if (!opt.hasOwnProperty(name)) {\n            opt[name] = defaultBindingOptions[name];\n          }\n        }\n      }\n      this._binding.push(new Binding(this, model, opt));\n    }\n  },\n\n  /**\n   * remove the view binding\n   */\n  removeBinding: function() {\n    if (this._binding) {\n      util.run(this._binding, 'destroy');\n    }\n  },\n\n\n  /**\n   * LAYOUT PROPERTIES\n   */\n\n  /**\n   * show the view\n   */\n  show: function(disp) {\n    if (disp) {\n      core.deprecated('view.show(disp)',\n        'view.show() (override the value of persistent display)');\n\n      // Override the persistent display\n      this.setPersistentDisplay(disp);\n    }\n\n    var currentDisplay = this.getStyle().display;\n    if (!currentDisplay || currentDisplay === 'none')  {\n      this.getStyle().display = this.getPersistentDisplay() || '';\n    }\n    return this;\n  },\n\n  /**\n   * hide the view\n   */\n  hide: function() {\n    var currentDisplay = this.getStyle().display || '';\n    if (currentDisplay && currentDisplay !== 'none') {\n      this.setPersistentDisplay(currentDisplay);\n    }\n    this.getStyle().display = 'none';\n    return this;\n  },\n\n  toggle: function(state) {\n    if (typeof state === 'undefined') {\n      state = this.getStyle().display === 'none';\n    }\n    return state ? this.show() : this.hide();\n  },\n\n  /**\n   * This is simply a duplication of the functions above, but in a form that is\n   * suitable for properties in buidler views.\n   */\n  setIsDisplayed: function(isDisplayed) {\n    if (isDisplayed) {\n      this.show();\n    } else {\n      this.hide();\n    }\n    return this;\n  },\n\n  getIsDisplayed: function() {\n    return this.getStyle().display !== 'none';\n  },\n\n  /**\n   * add a class to the view\n   */\n  addClass: function(className) {\n    dom.addClass(this.getNode(), className);\n    return this;\n  },\n\n  /**\n   * remove a class from the view\n   */\n  removeClass: function(className) {\n    dom.removeClass(this.getNode(), className);\n    return this;\n  },\n\n  // add a class if it is not present; remove it if it is\n  toggleClass: function(className) {\n    dom.toggleClass.apply(\n      dom,\n      [this.getNode()].concat(util.toArray(arguments)));\n    return this;\n  },\n\n  // COMPAT\n  conditionClass: function() {\n    core.deprecated('view.conditionClass', 'view.toggleClass');\n    return this.toggleClass.apply(this, arguments);\n  },\n\n  hasClass: function(className) {\n    return dom.hasClass(this.getNode(), className);\n  },\n\n  /**\n   * apply a css class that is mutually exclusive with other classes\n   * in a given set and save the state in an instance variable\n   *\n   * e.g.\n   *\n   * setMode('flavor', 'chocolate');\n   * setMode('flavor', 'vanilla');\n   * setMode('flavor', 'strawberry');\n   * would toggle between flavor-chocolate, flavor-vanilla and\n   * strawberry-flavor css classes and capture the value in this.modes.state.\n   *\n   * This is useful when you have a view that has various mutually exclusive\n   * modes that can be transitioned through via a top level css class.\n   */\n  setMode: function(mode, setting) {\n    var node = this.getNode(),\n        classes = node.className.split(/\\s+/),\n        newClasses = '',\n        regexp = new RegExp('^' + mode + '-');\n    for (var i = 0; i < classes.length; i += 1) {\n      var cssClass = classes[i];\n      if (!regexp.test(classes[i])) {\n        newClasses += ' ' + cssClass;\n      }\n    }\n    // if the mode being set is false then we remove\n    // any set mode.\n    this._modes = this._modes || {};\n    if (setting) {\n      newClasses += ' ' + mode + '-' + setting;\n      this._modes[mode] = setting;\n    } else {\n      delete this._modes[mode];\n    }\n    node.className = util.trim(newClasses);\n    return this;\n  },\n\n  /**\n   * get a mode value from the cache\n   */\n  getMode: function(mode) {\n    this._modes = this._modes || {};\n    return this._modes[mode];\n  },\n\n  /**\n   * get either all styles (no args) or a single style if name is provided\n   */\n  getStyle: function(name) {\n    var styles = this.getNode().style;\n    if (name) {\n      return styles[name];\n    } else {\n      return styles;\n    }\n  },\n\n  /**\n   * set attributes on the node\n   */\n  setAttributes: function(attributes) {\n    var node = this.getNode();\n    var name;\n\n    for (name in attributes) {\n      if (attributes.hasOwnProperty(name)) {\n        node.setAttribute(name, attributes[name] + emptyStr);\n      }\n    }\n  },\n\n  /**\n   * build a layout from a layout spec with the specified owner\n   */\n  build: function(config, owner) {\n    return builder.build(config, owner || this);\n  },\n\n  /**\n   * build and append a layout\n   */\n  setLayout: function(layout, owner) {\n    this.append(this.build(layout, owner));\n  },\n\n  getRect: function() {\n    return dom.getRect(this.getNode());\n  },\n\n  getScrollAdjustedRect: function() {\n    return dom.getScrollAdjustedRect(this.getNode());\n  },\n\n  /**\n   * Apply a set of styles to the view.  Supports three variants of arguments.\n   * The first is to pass the name and value of a single CSS property to\n   * change, where the name is camelCased, e.g.\n   *   setStyle('fontWeight', 'bold');\n   *\n   * The second is to pass a JSON object with name value pairs of one or more\n   * style values to change, where the names are camelCased, e.g.\n   *   setStyle({color: 'red', fontWeight: 'bold'});\n   *\n   * The third is to pass a CSS string, where names are hyphenated, and rules\n   * are separated with semi-colons, as in a CSS file.\n   *   setStyle('color:red; font-weight: bold;');\n   */\n  setStyle: function(styles) {\n    var styleObj = this.getNode().style;\n    var name;\n\n    if (arguments.length === 2) {\n      // Apply the name/value pair\n      styleObj[arguments[0]] = arguments[1];\n    } else if (typeof styles === 'string') {\n      styleObj.cssText += ';' + styles;\n    } else {\n      for (name in styles) {\n        if (styles.hasOwnProperty(name)) {\n          styleObj[name] = styles[name];\n        }\n      }\n    }\n    return this;\n  },\n\n  /**\n   * REFERENCES\n   */\n\n  /**\n   * get the reference for this view\n   */\n  getRef: function() {\n    return this._ref;\n  },\n\n  /**\n   * set the reference for the view\n   */\n  setRef: function(ref) {\n    this._ref = ref;\n    this._node.setAttribute('data-ref', ref);\n\n    var owner = this.getOwner();\n    owner.refs = owner.refs || {};\n    owner.refs[ref] = this;\n    return this;\n  },\n\n  _clearRef: function() {\n    var owner = this.getOwner();\n    var ref   = this.getRef();\n    if (ref && owner.refs) {\n      delete owner.refs[ref];\n    }\n  },\n\n\n  /**\n   * Insert the view into a node at the requested position\n   *\n   * @param node {Node|String} A DOM node, or the ID of a DOM node, in which\n   *                           to place this view.\n   * @param position {String}  Optional parameter. Specifies where to place the\n   *                           view within the DOM node. Acceptable values are\n   *                           'append', 'before', 'after' and 'prepend'. If no\n   *                           value is specified, the default is 'append'\n   */\n  placeIn: function(node, position) {\n    position = position || 'append';\n    var n = this.getNode();\n\n    if (typeof node === 'string') {\n      node = document.getElementById(node);\n    }\n    switch (position) {\n      case 'append':\n        node.appendChild(n);\n        break;\n      case 'before':\n        node.parentNode.insertBefore(n, node);\n        break;\n      case 'after':\n        node.parentNode.appendChild(n, node);\n        break;\n      case 'prepend':\n        node.insertBefore(n, node.firstChild);\n        break;\n      default:\n        throw \"Invalid node placement: \" + position;\n    }\n    this.setInDocument(true);\n\n    return this;\n  },\n\n  getInDocument: function() {\n    return this._inDocument;\n  },\n\n  setInDocument: function(state) {\n    state = !!state;\n    var old = !!this._inDocument;\n    if (old !== state) {\n      this._inDocument = state;\n      if (state && this.onDocumentInsertion) {\n        this.onDocumentInsertion();\n      }\n      util.run(this._childViews, 'setInDocument', state);\n    }\n    return this;\n  },\n\n  getParentView: function() {\n    return this._parentView;\n  },\n\n  setParentView: function(view) {\n    this._parentView = view;\n    return this.setInDocument(view && view.getInDocument());\n  },\n\n  /**\n   * remove the view from the dom without destroying it\n   */\n  remove: function() {\n    dom.removeElement(this.getNode());\n    return this;\n  },\n\n  /**\n   * destroy a view\n   *  - removes child views\n   *  - removes listeners\n   *  - cleans up references\n   */\n  destroy: function() {\n    dom.setData(this._node, 'view', null);\n    delete ContainerRegistry[dom.identify(this.getNode())];\n    util.run(this._childViews, 'destroy');\n    this._clearRef();\n    this.remove();\n    this.removeBinding();\n    this.isDestroyed = true;\n  },\n\n  /**\n   * CHILD VIEWS\n   */\n\n  getChildViews: function() {\n    return this._childViews;\n  },\n\n  setChildViews: function(childViews) {\n    if (__DEV__) {\n      if (!util.isArray(childViews)) {\n        console.error('setChildViews called with non-array:', childViews);\n      }\n    }\n\n    util.forEach(\n      this._childViews,\n      this.removeChild,\n      this);\n    if (childViews.length > 0) {\n      util.forEach(\n        builder.build(childViews, this.getOwner()),\n        this.appendChild,\n        this);\n    }\n  },\n\n  removeChild: function(child, doNotDestroy) {\n    child.setParentView(null);\n    child.setNextResponder(null);\n    child.setEventDispatcher(null);\n    this._childViews = util.without(this._childViews, child);\n    this._removeChildNode(child);\n    if (!doNotDestroy) {\n      child.destroy();\n    }\n    return this;\n  },\n\n  _removeChildNode: function(child) {\n    dom.removeElement(child.getNode());\n  },\n\n  append: function(arg) {\n    if (util.isArray(arg)) {\n      util.forEach(arg, this.appendChild, this);\n    } else {\n      this.appendChild(arg);\n    }\n  },\n\n  appendChild: function(child) {\n    this._childViews.push(child);\n    this._appendChildNode(child);\n    child.setParentView(this);\n    if (!child.getNextResponder()) {\n      child.setNextResponder(this);\n    }\n    child.setEventDispatcher(this.getEventDispatcher());\n    return this;\n  },\n\n  prependChild: function(child) {\n    this.insertChild(child, 0);\n  },\n\n  clearChildren: function() {\n    // Note that the input to setChildViews is discarded, and not mutated\n    // getChildViews returns an Array of zero or more View or TagView\n    // objects.\n    this.setChildViews(emptyArr);\n  },\n\n  // protected\n  _appendChildNode: function(child) {\n    this._node.appendChild(child.getNode());\n  },\n\n  insertChild: function(child, position) {\n    var children = this._childViews;\n    if (position === undefined) { position = children.length; }\n    if (position >= children.length) {\n      this.appendChild(child);\n    } else {\n      position = Math.max(0, position);\n      this._insertAt(child, position);\n    }\n    return this;\n  },\n\n  _insertAt: function(child, position) {\n    var children = this._childViews;\n    var beforeChild = children[position];\n    children.splice(position, 0, child);\n    this._insertNodeBefore(child, beforeChild);\n    child.setParentView(this);\n    if (!child.getNextResponder()) {\n      child.setNextResponder(this);\n    }\n    child.setEventDispatcher(this.getEventDispatcher());\n    return this;\n  },\n\n  // protected\n  _insertNodeBefore: function(child, beforeChild) {\n    this.getNode().insertBefore(child.getNode(), beforeChild.getNode());\n  },\n\n  /**\n   * find a reference within the views hierarchy\n   */\n  findRef: function(ref) {\n    if (this.refs) {\n      return this.refs[ref];\n    }\n    return null;\n  },\n\n  _nodeForEvent: function(name) {\n    return this.getNode();\n  }\n}, CanDelegateProperties);\n\n//@ sourceURL=bolt/mixins/container\n});");

// module: bolt/vendor/_
// file:   ../bolt/bolt/lib/vendor/_.js
eval("define(\"bolt/vendor/_\", function(require, exports, module) { //     Underscore.js 1.1.7\n//     (c) 2011 Jeremy Ashkenas, DocumentCloud Inc.\n//     Underscore is freely distributable under the MIT license.\n//     Portions of Underscore are inspired or borrowed from Prototype,\n//     Oliver Steele's Functional, and John Resig's Micro-Templating.\n//     For all details and documentation:\n//     http://documentcloud.github.com/underscore\n\n(function() {\n\n  // Baseline setup\n  // --------------\n\n  // Establish the root object, `window` in the browser, or `global` on the server.\n  var root = this;\n\n  // Save the previous value of the `_` variable.\n  var previousUnderscore = root._;\n\n  // Establish the object that gets returned to break out of a loop iteration.\n  var breaker = {};\n\n  // Save bytes in the minified (but not gzipped) version:\n  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;\n\n  // Create quick reference variables for speed access to core prototypes.\n  var slice            = ArrayProto.slice,\n      unshift          = ArrayProto.unshift,\n      toString         = ObjProto.toString,\n      hasOwnProperty   = ObjProto.hasOwnProperty;\n\n  // All **ECMAScript 5** native function implementations that we hope to use\n  // are declared here.\n  var\n    nativeForEach      = ArrayProto.forEach,\n    nativeMap          = ArrayProto.map,\n    nativeReduce       = ArrayProto.reduce,\n    nativeReduceRight  = ArrayProto.reduceRight,\n    nativeFilter       = ArrayProto.filter,\n    nativeEvery        = ArrayProto.every,\n    nativeSome         = ArrayProto.some,\n    nativeIndexOf      = ArrayProto.indexOf,\n    nativeLastIndexOf  = ArrayProto.lastIndexOf,\n    nativeIsArray      = Array.isArray,\n    nativeKeys         = Object.keys,\n    nativeBind         = FuncProto.bind;\n\n  // Create a safe reference to the Underscore object for use below.\n  var _ = function(obj) { return new wrapper(obj); };\n\n  // Export the Underscore object for **CommonJS**, with backwards-compatibility\n  // for the old `require()` API. If we're not in CommonJS, add `_` to the\n  // global object.\n  if (typeof module !== 'undefined' && module.exports) {\n    module.exports = _;\n    _._ = _;\n  } else {\n    // Exported as a string, for Closure Compiler \"advanced\" mode.\n    root['_'] = _;\n  }\n\n  // Current version.\n  _.VERSION = '1.1.7';\n\n  // Collection Functions\n  // --------------------\n\n  // The cornerstone, an `each` implementation, aka `forEach`.\n  // Handles objects with the built-in `forEach`, arrays, and raw objects.\n  // Delegates to **ECMAScript 5**'s native `forEach` if available.\n  var each = _.each = _.forEach = function(obj, iterator, context) {\n    if (obj == null) return;\n    if (nativeForEach && obj.forEach === nativeForEach) {\n      obj.forEach(iterator, context);\n    } else if (obj.length === +obj.length) {\n      for (var i = 0, l = obj.length; i < l; i++) {\n        if (i in obj && iterator.call(context, obj[i], i, obj) === breaker) return;\n      }\n    } else {\n      for (var key in obj) {\n        if (hasOwnProperty.call(obj, key)) {\n          if (iterator.call(context, obj[key], key, obj) === breaker) return;\n        }\n      }\n    }\n  };\n\n  // Return the results of applying the iterator to each element.\n  // Delegates to **ECMAScript 5**'s native `map` if available.\n  _.map = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);\n    each(obj, function(value, index, list) {\n      results[results.length] = iterator.call(context, value, index, list);\n    });\n    return results;\n  };\n\n  // **Reduce** builds up a single result from a list of values, aka `inject`,\n  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.\n  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {\n    var initial = memo !== void 0;\n    if (obj == null) obj = [];\n    if (nativeReduce && obj.reduce === nativeReduce) {\n      if (context) iterator = _.bind(iterator, context);\n      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);\n    }\n    each(obj, function(value, index, list) {\n      if (!initial) {\n        memo = value;\n        initial = true;\n      } else {\n        memo = iterator.call(context, memo, value, index, list);\n      }\n    });\n    if (!initial) throw new TypeError(\"Reduce of empty array with no initial value\");\n    return memo;\n  };\n\n  // The right-associative version of reduce, also known as `foldr`.\n  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.\n  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {\n    if (obj == null) obj = [];\n    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {\n      if (context) iterator = _.bind(iterator, context);\n      return memo !== void 0 ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);\n    }\n    var reversed = (_.isArray(obj) ? obj.slice() : _.toArray(obj)).reverse();\n    return _.reduce(reversed, iterator, memo, context);\n  };\n\n  // Return the first value which passes a truth test. Aliased as `detect`.\n  _.find = _.detect = function(obj, iterator, context) {\n    var result;\n    any(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) {\n        result = value;\n        return true;\n      }\n    });\n    return result;\n  };\n\n  // Return all the elements that pass a truth test.\n  // Delegates to **ECMAScript 5**'s native `filter` if available.\n  // Aliased as `select`.\n  _.filter = _.select = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(iterator, context);\n    each(obj, function(value, index, list) {\n      if (iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Return all the elements for which a truth test fails.\n  _.reject = function(obj, iterator, context) {\n    var results = [];\n    if (obj == null) return results;\n    each(obj, function(value, index, list) {\n      if (!iterator.call(context, value, index, list)) results[results.length] = value;\n    });\n    return results;\n  };\n\n  // Determine whether all of the elements match a truth test.\n  // Delegates to **ECMAScript 5**'s native `every` if available.\n  // Aliased as `all`.\n  _.every = _.all = function(obj, iterator, context) {\n    var result = true;\n    if (obj == null) return result;\n    if (nativeEvery && obj.every === nativeEvery) return obj.every(iterator, context);\n    each(obj, function(value, index, list) {\n      if (!(result = result && iterator.call(context, value, index, list))) return breaker;\n    });\n    return result;\n  };\n\n  // Determine if at least one element in the object matches a truth test.\n  // Delegates to **ECMAScript 5**'s native `some` if available.\n  // Aliased as `any`.\n  var any = _.some = _.any = function(obj, iterator, context) {\n    iterator = iterator || _.identity;\n    var result = false;\n    if (obj == null) return result;\n    if (nativeSome && obj.some === nativeSome) return obj.some(iterator, context);\n    each(obj, function(value, index, list) {\n      if (result |= iterator.call(context, value, index, list)) return breaker;\n    });\n    return !!result;\n  };\n\n  // Determine if a given value is included in the array or object using `===`.\n  // Aliased as `contains`.\n  _.include = _.contains = function(obj, target) {\n    var found = false;\n    if (obj == null) return found;\n    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;\n    any(obj, function(value) {\n      if (found = value === target) return true;\n    });\n    return found;\n  };\n\n  // Invoke a method (with arguments) on every item in a collection.\n  _.invoke = function(obj, method) {\n    var args = slice.call(arguments, 2);\n    return _.map(obj, function(value) {\n      return (method.call ? method || value : value[method]).apply(value, args);\n    });\n  };\n\n  // Convenience version of a common use case of `map`: fetching a property.\n  _.pluck = function(obj, key) {\n    return _.map(obj, function(value){ return value[key]; });\n  };\n\n  // Return the maximum element or (element-based computation).\n  _.max = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj)) return Math.max.apply(Math, obj);\n    var result = {computed : -Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed >= result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Return the minimum element (or element-based computation).\n  _.min = function(obj, iterator, context) {\n    if (!iterator && _.isArray(obj)) return Math.min.apply(Math, obj);\n    var result = {computed : Infinity};\n    each(obj, function(value, index, list) {\n      var computed = iterator ? iterator.call(context, value, index, list) : value;\n      computed < result.computed && (result = {value : value, computed : computed});\n    });\n    return result.value;\n  };\n\n  // Sort the object's values by a criterion produced by an iterator.\n  _.sortBy = function(obj, iterator, context) {\n    return _.pluck(_.map(obj, function(value, index, list) {\n      return {\n        value : value,\n        criteria : iterator.call(context, value, index, list)\n      };\n    }).sort(function(left, right) {\n      var a = left.criteria, b = right.criteria;\n      return a < b ? -1 : a > b ? 1 : 0;\n    }), 'value');\n  };\n\n  // Groups the object's values by a criterion produced by an iterator\n  _.groupBy = function(obj, iterator) {\n    var result = {};\n    each(obj, function(value, index) {\n      var key = iterator(value, index);\n      (result[key] || (result[key] = [])).push(value);\n    });\n    return result;\n  };\n\n  // Use a comparator function to figure out at what index an object should\n  // be inserted so as to maintain order. Uses binary search.\n  _.sortedIndex = function(array, obj, iterator) {\n    iterator || (iterator = _.identity);\n    var low = 0, high = array.length;\n    while (low < high) {\n      var mid = (low + high) >> 1;\n      iterator(array[mid]) < iterator(obj) ? low = mid + 1 : high = mid;\n    }\n    return low;\n  };\n\n  // Safely convert anything iterable into a real, live array.\n  _.toArray = function(iterable) {\n    if (!iterable)                return [];\n    if (iterable.toArray)         return iterable.toArray();\n    if (_.isArray(iterable))      return slice.call(iterable);\n    if (_.isArguments(iterable))  return slice.call(iterable);\n    return _.values(iterable);\n  };\n\n  // Return the number of elements in an object.\n  _.size = function(obj) {\n    return _.toArray(obj).length;\n  };\n\n  // Array Functions\n  // ---------------\n\n  // Get the first element of an array. Passing **n** will return the first N\n  // values in the array. Aliased as `head`. The **guard** check allows it to work\n  // with `_.map`.\n  _.first = _.head = function(array, n, guard) {\n    return (n != null) && !guard ? slice.call(array, 0, n) : array[0];\n  };\n\n  // Returns everything but the first entry of the array. Aliased as `tail`.\n  // Especially useful on the arguments object. Passing an **index** will return\n  // the rest of the values in the array from that index onward. The **guard**\n  // check allows it to work with `_.map`.\n  _.rest = _.tail = function(array, index, guard) {\n    return slice.call(array, (index == null) || guard ? 1 : index);\n  };\n\n  // Get the last element of an array.\n  _.last = function(array) {\n    return array[array.length - 1];\n  };\n\n  // Trim out all falsy values from an array.\n  _.compact = function(array) {\n    return _.filter(array, function(value){ return !!value; });\n  };\n\n  // Return a completely flattened version of an array.\n  _.flatten = function(array) {\n    return _.reduce(array, function(memo, value) {\n      if (_.isArray(value)) return memo.concat(_.flatten(value));\n      memo[memo.length] = value;\n      return memo;\n    }, []);\n  };\n\n  // Return a version of the array that does not contain the specified value(s).\n  _.without = function(array) {\n    return _.difference(array, slice.call(arguments, 1));\n  };\n\n  // Produce a duplicate-free version of the array. If the array has already\n  // been sorted, you have the option of using a faster algorithm.\n  // Aliased as `unique`.\n  _.uniq = _.unique = function(array, isSorted) {\n    return _.reduce(array, function(memo, el, i) {\n      if (0 == i || (isSorted === true ? _.last(memo) != el : !_.include(memo, el))) memo[memo.length] = el;\n      return memo;\n    }, []);\n  };\n\n  // Produce an array that contains the union: each distinct element from all of\n  // the passed-in arrays.\n  _.union = function() {\n    return _.uniq(_.flatten(arguments));\n  };\n\n  // Produce an array that contains every item shared between all the\n  // passed-in arrays. (Aliased as \"intersect\" for back-compat.)\n  _.intersection = _.intersect = function(array) {\n    var rest = slice.call(arguments, 1);\n    return _.filter(_.uniq(array), function(item) {\n      return _.every(rest, function(other) {\n        return _.indexOf(other, item) >= 0;\n      });\n    });\n  };\n\n  // Take the difference between one array and another.\n  // Only the elements present in just the first array will remain.\n  _.difference = function(array, other) {\n    return _.filter(array, function(value){ return !_.include(other, value); });\n  };\n\n  // Zip together multiple lists into a single array -- elements that share\n  // an index go together.\n  _.zip = function() {\n    var args = slice.call(arguments);\n    var length = _.max(_.pluck(args, 'length'));\n    var results = new Array(length);\n    for (var i = 0; i < length; i++) results[i] = _.pluck(args, \"\" + i);\n    return results;\n  };\n\n  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),\n  // we need this function. Return the position of the first occurrence of an\n  // item in an array, or -1 if the item is not included in the array.\n  // Delegates to **ECMAScript 5**'s native `indexOf` if available.\n  // If the array is large and already in sort order, pass `true`\n  // for **isSorted** to use binary search.\n  _.indexOf = function(array, item, isSorted) {\n    if (array == null) return -1;\n    var i, l;\n    if (isSorted) {\n      i = _.sortedIndex(array, item);\n      return array[i] === item ? i : -1;\n    }\n    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item);\n    for (i = 0, l = array.length; i < l; i++) if (array[i] === item) return i;\n    return -1;\n  };\n\n\n  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.\n  _.lastIndexOf = function(array, item) {\n    if (array == null) return -1;\n    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) return array.lastIndexOf(item);\n    var i = array.length;\n    while (i--) if (array[i] === item) return i;\n    return -1;\n  };\n\n  // Generate an integer Array containing an arithmetic progression. A port of\n  // the native Python `range()` function. See\n  // [the Python documentation](http://docs.python.org/library/functions.html#range).\n  _.range = function(start, stop, step) {\n    if (arguments.length <= 1) {\n      stop = start || 0;\n      start = 0;\n    }\n    step = arguments[2] || 1;\n\n    var len = Math.max(Math.ceil((stop - start) / step), 0);\n    var idx = 0;\n    var range = new Array(len);\n\n    while(idx < len) {\n      range[idx++] = start;\n      start += step;\n    }\n\n    return range;\n  };\n\n  // Function (ahem) Functions\n  // ------------------\n\n  // Create a function bound to a given object (assigning `this`, and arguments,\n  // optionally). Binding with arguments is also known as `curry`.\n  // Delegates to **ECMAScript 5**'s native `Function.bind` if available.\n  // We check for `func.bind` first, to fail fast when `func` is undefined.\n  _.bind = function(func, obj) {\n    if (func.bind === nativeBind && nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));\n    var args = slice.call(arguments, 2);\n    return function() {\n      return func.apply(obj, args.concat(slice.call(arguments)));\n    };\n  };\n\n  // Bind all of an object's methods to that object. Useful for ensuring that\n  // all callbacks defined on an object belong to it.\n  _.bindAll = function(obj) {\n    var funcs = slice.call(arguments, 1);\n    if (funcs.length == 0) funcs = _.functions(obj);\n    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });\n    return obj;\n  };\n\n  // Memoize an expensive function by storing its results.\n  _.memoize = function(func, hasher) {\n    var memo = {};\n    hasher || (hasher = _.identity);\n    return function() {\n      var key = hasher.apply(this, arguments);\n      return hasOwnProperty.call(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));\n    };\n  };\n\n  // Delays a function for the given number of milliseconds, and then calls\n  // it with the arguments supplied.\n  _.delay = function(func, wait) {\n    var args = slice.call(arguments, 2);\n    return setTimeout(function(){ return func.apply(func, args); }, wait);\n  };\n\n  // Defers a function, scheduling it to run after the current call stack has\n  // cleared.\n  _.defer = function(func) {\n    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));\n  };\n\n  // Internal function used to implement `_.throttle` and `_.debounce`.\n  var limit = function(func, wait, debounce) {\n    var timeout;\n    return function() {\n      var context = this, args = arguments;\n      var throttler = function() {\n        timeout = null;\n        func.apply(context, args);\n      };\n      if (debounce) clearTimeout(timeout);\n      if (debounce || !timeout) timeout = setTimeout(throttler, wait);\n    };\n  };\n\n  // Returns a function, that, when invoked, will only be triggered at most once\n  // during a given window of time.\n  _.throttle = function(func, wait) {\n    return limit(func, wait, false);\n  };\n\n  // Returns a function, that, as long as it continues to be invoked, will not\n  // be triggered. The function will be called after it stops being called for\n  // N milliseconds.\n  _.debounce = function(func, wait) {\n    return limit(func, wait, true);\n  };\n\n  // Returns a function that will be executed at most one time, no matter how\n  // often you call it. Useful for lazy initialization.\n  _.once = function(func) {\n    var ran = false, memo;\n    return function() {\n      if (ran) return memo;\n      ran = true;\n      return memo = func.apply(this, arguments);\n    };\n  };\n\n  // Returns the first function passed as an argument to the second,\n  // allowing you to adjust arguments, run code before and after, and\n  // conditionally execute the original function.\n  _.wrap = function(func, wrapper) {\n    return function() {\n      var args = [func].concat(slice.call(arguments));\n      return wrapper.apply(this, args);\n    };\n  };\n\n  // Returns a function that is the composition of a list of functions, each\n  // consuming the return value of the function that follows.\n  _.compose = function() {\n    var funcs = slice.call(arguments);\n    return function() {\n      var args = slice.call(arguments);\n      for (var i = funcs.length - 1; i >= 0; i--) {\n        args = [funcs[i].apply(this, args)];\n      }\n      return args[0];\n    };\n  };\n\n  // Returns a function that will only be executed after being called N times.\n  _.after = function(times, func) {\n    return function() {\n      if (--times < 1) { return func.apply(this, arguments); }\n    };\n  };\n\n\n  // Object Functions\n  // ----------------\n\n  // Retrieve the names of an object's properties.\n  // Delegates to **ECMAScript 5**'s native `Object.keys`\n  _.keys = nativeKeys || function(obj) {\n    if (obj !== Object(obj)) throw new TypeError('Invalid object');\n    var keys = [];\n    for (var key in obj) if (hasOwnProperty.call(obj, key)) keys[keys.length] = key;\n    return keys;\n  };\n\n  // Retrieve the values of an object's properties.\n  _.values = function(obj) {\n    return _.map(obj, _.identity);\n  };\n\n  // Return a sorted list of the function names available on the object.\n  // Aliased as `methods`\n  _.functions = _.methods = function(obj) {\n    var names = [];\n    for (var key in obj) {\n      if (_.isFunction(obj[key])) names.push(key);\n    }\n    return names.sort();\n  };\n\n  // Extend a given object with all the properties in passed-in object(s).\n  _.extend = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        if (source[prop] !== void 0) obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Fill in a given object with default properties.\n  _.defaults = function(obj) {\n    each(slice.call(arguments, 1), function(source) {\n      for (var prop in source) {\n        if (obj[prop] == null) obj[prop] = source[prop];\n      }\n    });\n    return obj;\n  };\n\n  // Create a (shallow-cloned) duplicate of an object.\n  _.clone = function(obj) {\n    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);\n  };\n\n  // Invokes interceptor with the obj, and then returns obj.\n  // The primary purpose of this method is to \"tap into\" a method chain, in\n  // order to perform operations on intermediate results within the chain.\n  _.tap = function(obj, interceptor) {\n    interceptor(obj);\n    return obj;\n  };\n\n  // Perform a deep comparison to check if two objects are equal.\n  _.isEqual = function(a, b) {\n    // Check object identity.\n    if (a === b) return true;\n    // Different types?\n    var atype = typeof(a), btype = typeof(b);\n    if (atype != btype) return false;\n    // Basic equality test (watch out for coercions).\n    if (a == b) return true;\n    // One is falsy and the other truthy.\n    if ((!a && b) || (a && !b)) return false;\n    // Unwrap any wrapped objects.\n    if (a._chain) a = a._wrapped;\n    if (b._chain) b = b._wrapped;\n    // One of them implements an isEqual()?\n    if (a.isEqual) return a.isEqual(b);\n    if (b.isEqual) return b.isEqual(a);\n    // Check dates' integer values.\n    if (_.isDate(a) && _.isDate(b)) return a.getTime() === b.getTime();\n    // Both are NaN?\n    if (_.isNaN(a) && _.isNaN(b)) return false;\n    // Compare regular expressions.\n    if (_.isRegExp(a) && _.isRegExp(b))\n      return a.source     === b.source &&\n             a.global     === b.global &&\n             a.ignoreCase === b.ignoreCase &&\n             a.multiline  === b.multiline;\n    // If a is not an object by this point, we can't handle it.\n    if (atype !== 'object') return false;\n    // Check for different array lengths before comparing contents.\n    if (a.length && (a.length !== b.length)) return false;\n    // Nothing else worked, deep compare the contents.\n    var aKeys = _.keys(a), bKeys = _.keys(b);\n    // Different object sizes?\n    if (aKeys.length != bKeys.length) return false;\n    // Recursive comparison of contents.\n    for (var key in a) if (!(key in b) || !_.isEqual(a[key], b[key])) return false;\n    return true;\n  };\n\n  // Is a given array or object empty?\n  _.isEmpty = function(obj) {\n    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;\n    for (var key in obj) if (hasOwnProperty.call(obj, key)) return false;\n    return true;\n  };\n\n  // Is a given value a DOM element?\n  _.isElement = function(obj) {\n    return !!(obj && obj.nodeType == 1);\n  };\n\n  // Is a given value an array?\n  // Delegates to ECMA5's native Array.isArray\n  _.isArray = nativeIsArray || function(obj) {\n    return toString.call(obj) === '[object Array]';\n  };\n\n  // Is a given variable an object?\n  _.isObject = function(obj) {\n    return obj === Object(obj);\n  };\n\n  // Is a given variable an arguments object?\n  _.isArguments = function(obj) {\n    return !!(obj && hasOwnProperty.call(obj, 'callee'));\n  };\n\n  // Is a given value a function?\n  _.isFunction = function(obj) {\n    return !!(obj && obj.constructor && obj.call && obj.apply);\n  };\n\n  // Is a given value a string?\n  _.isString = function(obj) {\n    return !!(obj === '' || (obj && obj.charCodeAt && obj.substr));\n  };\n\n  // Is a given value a number?\n  _.isNumber = function(obj) {\n    return !!(obj === 0 || (obj && obj.toExponential && obj.toFixed));\n  };\n\n  // Is the given value `NaN`? `NaN` happens to be the only value in JavaScript\n  // that does not equal itself.\n  _.isNaN = function(obj) {\n    return obj !== obj;\n  };\n\n  // Is a given value a boolean?\n  _.isBoolean = function(obj) {\n    return obj === true || obj === false;\n  };\n\n  // Is a given value a date?\n  _.isDate = function(obj) {\n    return !!(obj && obj.getTimezoneOffset && obj.setUTCFullYear);\n  };\n\n  // Is the given value a regular expression?\n  _.isRegExp = function(obj) {\n    return !!(obj && obj.test && obj.exec && (obj.ignoreCase || obj.ignoreCase === false));\n  };\n\n  // Is a given value equal to null?\n  _.isNull = function(obj) {\n    return obj === null;\n  };\n\n  // Is a given variable undefined?\n  _.isUndefined = function(obj) {\n    return obj === void 0;\n  };\n\n  // Utility Functions\n  // -----------------\n\n  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its\n  // previous owner. Returns a reference to the Underscore object.\n  _.noConflict = function() {\n    root._ = previousUnderscore;\n    return this;\n  };\n\n  // Keep the identity function around for default iterators.\n  _.identity = function(value) {\n    return value;\n  };\n\n  // Run a function **n** times.\n  _.times = function (n, iterator, context) {\n    for (var i = 0; i < n; i++) iterator.call(context, i);\n  };\n\n  // Add your own custom functions to the Underscore object, ensuring that\n  // they're correctly added to the OOP wrapper as well.\n  _.mixin = function(obj) {\n    each(_.functions(obj), function(name){\n      addToWrapper(name, _[name] = obj[name]);\n    });\n  };\n\n  // Generate a unique integer id (unique within the entire client session).\n  // Useful for temporary DOM ids.\n  var idCounter = 0;\n  _.uniqueId = function(prefix) {\n    var id = idCounter++;\n    return prefix ? prefix + id : id;\n  };\n\n  // By default, Underscore uses ERB-style template delimiters, change the\n  // following template settings to use alternative delimiters.\n  _.templateSettings = {\n    evaluate    : /<%([\\s\\S]+?)%>/g,\n    interpolate : /<%=([\\s\\S]+?)%>/g\n  };\n\n  // JavaScript micro-templating, similar to John Resig's implementation.\n  // Underscore templating handles arbitrary delimiters, preserves whitespace,\n  // and correctly escapes quotes within interpolated code.\n  _.template = function(str, data) {\n    var c  = _.templateSettings;\n    var tmpl = 'var __p=[],print=function(){__p.push.apply(__p,arguments);};' +\n      'with(obj||{}){__p.push(\\'' +\n      str.replace(/\\\\/g, '\\\\\\\\')\n         .replace(/'/g, \"\\\\'\")\n         .replace(c.interpolate, function(match, code) {\n           return \"',\" + code.replace(/\\\\'/g, \"'\") + \",'\";\n         })\n         .replace(c.evaluate || null, function(match, code) {\n           return \"');\" + code.replace(/\\\\'/g, \"'\")\n                              .replace(/[\\r\\n\\t]/g, ' ') + \"__p.push('\";\n         })\n         .replace(/\\r/g, '\\\\r')\n         .replace(/\\n/g, '\\\\n')\n         .replace(/\\t/g, '\\\\t')\n         + \"');}return __p.join('');\";\n    var func = new Function('obj', tmpl);\n    return data ? func(data) : func;\n  };\n\n  // The OOP Wrapper\n  // ---------------\n\n  // If Underscore is called as a function, it returns a wrapped object that\n  // can be used OO-style. This wrapper holds altered versions of all the\n  // underscore functions. Wrapped objects may be chained.\n  var wrapper = function(obj) { this._wrapped = obj; };\n\n  // Expose `wrapper.prototype` as `_.prototype`\n  _.prototype = wrapper.prototype;\n\n  // Helper function to continue chaining intermediate results.\n  var result = function(obj, chain) {\n    return chain ? _(obj).chain() : obj;\n  };\n\n  // A method to easily add functions to the OOP wrapper.\n  var addToWrapper = function(name, func) {\n    wrapper.prototype[name] = function() {\n      var args = slice.call(arguments);\n      unshift.call(args, this._wrapped);\n      return result(func.apply(_, args), this._chain);\n    };\n  };\n\n  // Add all of the Underscore functions to the wrapper object.\n  _.mixin(_);\n\n  // Add all mutator Array functions to the wrapper.\n  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      method.apply(this._wrapped, arguments);\n      return result(this._wrapped, this._chain);\n    };\n  });\n\n  // Add all accessor Array functions to the wrapper.\n  each(['concat', 'join', 'slice'], function(name) {\n    var method = ArrayProto[name];\n    wrapper.prototype[name] = function() {\n      return result(method.apply(this._wrapped, arguments), this._chain);\n    };\n  });\n\n  // Start chaining a wrapped Underscore object.\n  wrapper.prototype.chain = function() {\n    this._chain = true;\n    return this;\n  };\n\n  // Extracts the result from a wrapped and chained object.\n  wrapper.prototype.value = function() {\n    return this._wrapped;\n  };\n\n}).call(this);\n\n//@ sourceURL=bolt/vendor/_\n});");

if (__PERF__) { modulr.perf.defineEnd = modulr.perf.requireMainStart = Date.now(); }

require("lib/main");

if (__PERF__) { modulr.perf.requireMainEnd = modulr.perf.end = Date.now(); }
